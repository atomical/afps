You are OpenAI Codex acting as a senior multiplayer gameplay engineer + tools engineer. You have full access to this repository. Implement a complete, data-driven weapon settings system for EVERY weapon in the project, including ammo, fire cadence, fire mode, server-synced casing/shell ejection visuals, and fully generated (non-placeholder) sound effects for fire/reload/etc.

ABSOLUTE REQUIREMENTS (do not violate):
1) NO PLACEHOLDERS anywhere:
   - No TODOs, no “set this later”, no null/empty clip references, no missing assets, no “insert asset id here”.
   - Any weapon definition must be complete and have real numeric values.
   - Any sound referenced must be generated by code (procedural) OR generated into real audio files committed/created by tooling so the game has actual audible SFX immediately.
2) Each gun type (weapon) MUST have a definition that includes, at minimum:
   - maxAmmo (magazine capacity / ammo-in-mag max)
   - cooldownSeconds (time between shots)
   - fireMode (SEMI or FULL_AUTO)
3) Add a per-weapon setting:
   - ejectShellsWhileFiring (bool)
   - If true, shells/casings eject on each shot (or each pellet shot event for shotguns — still 1 casing per trigger pull unless weapon specifically uses multiple).
4) Shell/casing ejection must be server-synced so other players can see it.
   - Do NOT spawn a fully networked rigidbody casing object per shot (too expensive).
   - Instead: replicate a deterministic “EjectCasing” event from server → all clients with position/rotation/velocity seed so every client spawns the same visual locally.
5) Sound effects:
   - Fire, dry-fire (empty click), reload, equip/raise (if your game has it), plus casing “tink” impacts.
   - Fire & reload sounds must be audible to nearby players (replicate via the same server-authoritative events).
6) Use the existing “bullet” asset/model in the Blaster Kit already in the project as the casing/shell visual.
   - Search the repo to locate the Blaster Kit bullet mesh/prefab/model.
   - Create a dedicated casing prefab that uses that mesh (do NOT repurpose the actual projectile object if it’s used for gameplay).
7) Implement for ALL weapons present in the project.
   - Discover weapons by scanning prefabs/resources/scripts (whatever matches this repo) and enumerate them.
   - If the repo currently has hardcoded ammo/cooldown/firemode values, migrate them into the new WeaponDefinition entries (preserve existing gameplay feel).
   - If some weapons have no prior data, use the “Default balancing table” below exactly (real numbers provided) and ensure they are used.

CONTEXT DISCOVERY (first thing you do):
A) Identify the project type and networking layer by scanning repository:
   - Unity? Look for Assets/, ProjectSettings/, Packages/manifest.json.
   - Unreal? Look for .uproject, Source/.
   - Godot? Look for project.godot.
   - Web? Look for package.json + src/ + a server folder.
   - Roblox? Look for .rbxl, Luau, ReplicatedStorage/ etc.
B) Determine current weapon firing flow:
   - Where input triggers “TryFire()”
   - Where ammo is stored
   - Where projectiles/traces are spawned
   - Where server authority lives
C) Determine how the project already replicates shooting (if it does):
   - existing RPC/event types
   - existing “spawn VFX” message pattern
You MUST integrate into the existing patterns and style of the repo (naming, folder structure, networking abstraction).

DESIGN TO IMPLEMENT (must be clean + scalable):
1) WeaponDefinition + Registry
   - Create a central WeaponDatabase/WeaponRegistry that maps WeaponId → WeaponDefinition.
   - WeaponDefinition must include:
     * id (stable string or enum)
     * displayName (string)
     * maxAmmoInMag (int)  [THIS satisfies “maximum amount of ammo” requirement]
     * cooldownSeconds (float)
     * fireMode (enum: SEMI, FULL_AUTO)
     * ejectShellsWhileFiring (bool)
     * casingEject:
         - prefab/asset reference to casing visual (derived from Blaster Kit bullet)
         - ejectLocalOffset / or a named transform socket (“EjectPort”)
         - initial velocity range (min/max)
         - angular velocity range
         - lifetimeSeconds
     * sounds:
         - fire (AudioClip / sound asset reference)
         - fireVariant2 (optional but must be real if present)
         - dryFire
         - reload
         - equip (if your game has equip)
         - casingImpact1 / casingImpact2 (optional but real if present)
     * (optional but recommended) reloadSeconds, reserveAmmoMax, pellets, etc — only if they exist in current game logic.
   - Add runtime validation (development builds): on startup, validate that every weapon in the project has a WeaponDefinition entry AND that every sound reference resolves AND that casing prefab resolves when ejectShellsWhileFiring is true. Fail loudly with actionable error.

2) Server-authoritative fire + replicated cosmetic events
   - Implement/extend server-authoritative “FireWeapon” request handling (if already exists, modify it).
   - When server approves a shot:
     - Decrement ammo on server.
     - Spawn gameplay projectile / raycast damage as currently done.
     - Broadcast a replicated “WeaponFired” event to all clients (including shooter) containing:
         shooterNetId
         weaponId
         serverTickOrTime
         muzzleWorldPos
         muzzleWorldRot (or forward vector)
         shotSequenceNumber (monotonic per shooter for deterministic variation)
         casingEjectData:
           enabled bool (from WeaponDefinition)
           ejectPortWorldPos
           ejectPortWorldRot
           initialVelocity (Vector3)  (server-chosen so all clients match)
           initialAngularVelocity (Vector3)
           rngSeed (uint)  (derived from serverTick + shooter + shotSequenceNumber)
     - Clients receiving WeaponFired:
         - play muzzle flash/tracer as already done
         - play fire sound as 3D audio at muzzle position
         - if casing enabled: spawn local casing visual with that initial velocity & spin
   - IMPORTANT: do NOT trust client to decide casing ejection. Clients may request fire, but server decides whether it happened.

3) Shell/Casing prefab + pooling + local physics
   - Create “Casing” prefab that uses the Blaster Kit bullet mesh/model:
     - Add collider + rigidbody (or equivalent physics component) appropriate to engine.
     - Use continuous collision if needed to avoid tunneling.
     - Mass small (e.g., 0.01–0.03), moderate drag.
     - LifetimeSeconds per WeaponDefinition; auto-despawn via pooling.
   - Implement object pool for casings on each client to avoid allocations.
   - Casing impacts:
     - On collision with world, play a small “tink” sound (randomly choose from casingImpact sounds).
     - Rate-limit impacts per casing so it doesn’t spam on jittering contacts (e.g., min 0.08s between impacts, max 4 impacts).
   - Casing visual does not need to be identical physics across clients; only spawn timing and initial conditions must match.

4) Sound generation (NO placeholders)
   - You must provide real audible sounds without downloading external assets.
   - Implement procedural audio synthesis that generates the needed clips at runtime OR generate actual .wav assets through an editor/tool script checked into the repo.
   - Choose the best approach based on engine:
     - Unity: Create AudioClip from float samples OR generate .wav files into Assets/Audio/Generated and rely on Unity importer.
     - Godot: Generate AudioStreamSample.
     - Unreal: Generate USoundWave (harder; if too hard, generate .wav files in Content/ and import steps if tooling exists).
     - Web: Generate AudioBuffer via WebAudio.
     - Roblox: You CANNOT procedurally create SoundId; if this is Roblox, you must instead generate .ogg/.wav files and include a documented import step is not acceptable as “no placeholders”.
       => Therefore, if the repo is Roblox, implement runtime synthesis using available APIs is impossible; in that case, you MUST implement a tool that generates real audio files AND ensure the project references them in a way Roblox accepts in-repo (if the repo already has a pipeline for asset IDs). If there is no pipeline, stop and implement a local preview with generated audio plus a strict checklist + fail-fast validation that prevents shipping with missing sound IDs. BUT still: no placeholder IDs in code; treat missing pipeline as a build error.

   - Sound style:
     - These are stylized sci‑fi/arcade “blaster” sounds (since project contains Blaster Kit).
     - Use layered synthesis: short transient + noise burst + decaying tone + optional reverb tail.
     - Make each weapon’s fire sound distinct by changing base frequency, noise color, decay, and distortion.
     - Reload sounds should be mechanical clicks/clacks (short transients in sequence).
     - Dry-fire: short click with almost no tail.
     - Casing impact: tiny high‑frequency ping (very short).

   - Determinism:
     - Sounds can have minor random variation, BUT choose variants deterministically from (weaponId, shotSequenceNumber) so all clients hear the same variant for a given shot.

DEFAULT BALANCING TABLE (USE THESE EXACT VALUES IF NO EXISTING VALUES ARE PRESENT)
WeaponId, DisplayName, maxAmmoInMag, cooldownSeconds, fireMode, ejectShellsWhileFiring
PISTOL_9MM,        "9mm Pistol",            15, 0.180, SEMI,      true
PISTOL_45,         ".45 Sidearm",           12, 0.200, SEMI,      true
REVOLVER_357,      ".357 Revolver",          6, 0.350, SEMI,      false   (revolvers don’t eject per shot)
SMG_9MM,           "9mm SMG",               30, 0.080, FULL_AUTO, true
AR_556,            "5.56 Rifle",            30, 0.100, FULL_AUTO, true
CARBINE_762,       "7.62 Carbine",          25, 0.115, FULL_AUTO, true
DMR_762,           "7.62 DMR",              20, 0.225, SEMI,      true
LMG_556,           "5.56 LMG",             100, 0.085, FULL_AUTO, true
SHOTGUN_PUMP,      "Pump Shotgun",           8, 0.900, SEMI,      true
SHOTGUN_AUTO,      "Auto Shotgun",          12, 0.250, FULL_AUTO, true
SNIPER_BOLT,       "Bolt Sniper",            5, 1.250, SEMI,      true
GRENADE_LAUNCHER,  "Grenade Launcher",       6, 0.800, SEMI,      false
ROCKET_LAUNCHER,   "Rocket Launcher",        1, 1.500, SEMI,      false
ENERGY_RIFLE,      "Energy Rifle",          40, 0.090, FULL_AUTO, false   (energy weapons: no casings)

SFX GENERATION SPEC (MUST PRODUCE REAL AUDIO, NO PLACEHOLDERS)
Generate these clips per weapon (at minimum):
- {weaponId}_fire
- {weaponId}_reload
- {weaponId}_dry
Plus global:
- casing_impact_01
- casing_impact_02

If engine supports runtime procedural clips:
- Use sampleRate = 44100 Hz, mono.
- Fire clip length:
  * pistols/smg/ar/lmg/energy: 0.18–0.30 s
  * shotgun: 0.45 s
  * sniper: 0.55 s
  * launchers: 0.65 s
- Reload length:
  * pistols: 0.70 s
  * rifles/smg: 0.95 s
  * lmg: 1.20 s
  * shotgun pump: 1.05 s
  * sniper: 1.10 s
  * launchers: 1.10 s
  * energy: 0.90 s
- Dry-fire: 0.10 s
- Casing impact: 0.05 s

Procedural recipe primitives (implement these in code, not as pseudocode):
A) Envelope: exponential decay e(t) = exp(-t / tau) with tau per layer.
B) Tone layer: sin(2π f(t) t) where f(t) can drop slightly during the shot (pitch drop).
C) Noise layer: white noise passed through a simple one‑pole lowpass/highpass to color it.
D) Distortion: soft clip tanh(k * x) with k depending on weapon.
E) Simple reverb tail (optional): feedback comb or very small convolution with a generated impulse; keep CPU cheap; or precompute once per clip.

Per-weapon fire sound parameters (use exactly):
PISTOL_9MM:
  baseToneHz=220, pitchDrop=0.08, noiseHP=1400, noiseLP=8000, tau=0.060, distortion=1.8
PISTOL_45:
  baseToneHz=190, pitchDrop=0.10, noiseHP=1100, noiseLP=7000, tau=0.070, distortion=2.0
REVOLVER_357:
  baseToneHz=170, pitchDrop=0.12, noiseHP=900,  noiseLP=6500, tau=0.085, distortion=2.2
SMG_9MM:
  baseToneHz=240, pitchDrop=0.07, noiseHP=1600, noiseLP=9000, tau=0.050, distortion=1.7
AR_556:
  baseToneHz=160, pitchDrop=0.09, noiseHP=1200, noiseLP=8500, tau=0.075, distortion=2.1
CARBINE_762:
  baseToneHz=140, pitchDrop=0.10, noiseHP=1000, noiseLP=8200, tau=0.085, distortion=2.3
DMR_762:
  baseToneHz=135, pitchDrop=0.11, noiseHP=950,  noiseLP=7800, tau=0.095, distortion=2.4
LMG_556:
  baseToneHz=150, pitchDrop=0.08, noiseHP=1050, noiseLP=8200, tau=0.080, distortion=2.0
SHOTGUN_PUMP:
  baseToneHz=110, pitchDrop=0.14, noiseHP=600,  noiseLP=6200, tau=0.140, distortion=2.6, extraBoomSubHz=60 (low sine burst)
SHOTGUN_AUTO:
  baseToneHz=120, pitchDrop=0.12, noiseHP=650,  noiseLP=6500, tau=0.120, distortion=2.5, extraBoomSubHz=65
SNIPER_BOLT:
  baseToneHz=95,  pitchDrop=0.16, noiseHP=500,  noiseLP=6000, tau=0.200, distortion=2.8, crackHP=2500 (add short high crack)
GRENADE_LAUNCHER:
  baseToneHz=80,  pitchDrop=0.18, noiseHP=350,  noiseLP=5200, tau=0.240, distortion=3.0, extraBoomSubHz=50
ROCKET_LAUNCHER:
  baseToneHz=70,  pitchDrop=0.20, noiseHP=300,  noiseLP=4800, tau=0.280, distortion=3.2, extraBoomSubHz=45, tailSeconds=0.35
ENERGY_RIFLE:
  baseToneHz=420, pitchDrop=0.04, noiseHP=2200, noiseLP=12000, tau=0.070, distortion=1.2, addChirp=true (frequency sweep 900→450 over 0.12s)

Reload sound procedural recipe (mechanical):
- Construct as 3–7 short transients spaced over the reload duration:
  click = damped sine at 700–1300 Hz for 8–15ms + a tiny noise burst.
- For each weapon category, use fixed click count & timings:
  pistols: 4 clicks at t=[0.08, 0.22, 0.45, 0.62]
  rifles/smg: 5 clicks at t=[0.08, 0.20, 0.44, 0.62, 0.84]
  lmg: 6 clicks at t=[0.10, 0.28, 0.46, 0.66, 0.86, 1.06]
  shotgun pump: 6 clicks at t=[0.10, 0.26, 0.42, 0.58, 0.74, 0.92]
  sniper: 5 clicks at t=[0.12, 0.34, 0.56, 0.78, 0.98]
  launchers: 5 clicks at t=[0.14, 0.36, 0.58, 0.80, 1.02]
  energy: 4 clicks + one “power-up hum” (sine 320 Hz decaying)

Dry-fire recipe:
- 2–3ms impulse + 18ms damped sine ~ 1000 Hz, very low amplitude, no reverb.

Casing impacts:
- Two variants:
  casing_impact_01: damped sine 2800 Hz, 35ms, slight pitch wobble
  casing_impact_02: damped sine 2400 Hz, 45ms

IMPLEMENTATION DETAILS (write real code, not pseudocode):
1) Add/modify the weapon config layer:
   - If the project already has ScriptableObjects / JSON / YAML for weapons, extend it.
   - Else, create a WeaponDatabase asset or config file. MUST be loaded on server + client.
   - Ensure the server uses the same definitions as the client to decide casing behavior and to clamp fire cadence.

2) Add WeaponId enumeration:
   - Use stable identifiers. If weapons already exist (prefabs or item ids), use those ids.
   - Map each existing weapon to one of the above defaults by closest match (and document mapping in code comments).

3) Update firing logic:
   - Semi: one shot per input press.
   - Full auto: repeated shots while input held, respecting cooldownSeconds.
   - Server authoritative rate limiting: server rejects fire requests faster than cooldownSeconds for that weapon.

4) Networking integration:
   - Use existing RPC/event system.
   - Add these messages if not present:
     - FireWeaponRequest (client→server) [weaponId, aim origin/dir, clientShotSeq]
     - WeaponFiredEvent (server→all clients) [shooterId, weaponId, serverTime, muzzleTransform, shotSeq, casingEjectPayload]
     - WeaponReloadedEvent or ReloadStartedEvent (server→all clients, optional but required if other players should hear reload)
   - Ensure reliable/unreliable choice fits the engine:
     - WeaponFiredEvent should be UNRELIABLE if available (it’s cosmetic + frequent), but must be ordered per shooter if possible.
     - Reload events can be reliable.

5) Casing spawn on clients:
   - On WeaponFiredEvent:
     - if definition.ejectShellsWhileFiring:
       - spawn casing from pool at ejectPortWorldPos/Rot
       - apply initial velocity and angular velocity from event
       - set lifetime timer and despawn back to pool
   - Eject port:
     - Prefer an existing socket/transform on weapon viewmodel/worldmodel.
     - If none exists, create a reasonable offset relative to the muzzle/right side and store it in WeaponDefinition as a local offset (real numeric offsets; do not leave blank).

6) “Blaster Kit bullet” casing asset:
   - Search for the bullet mesh/model in the project (by name “bullet”, “Bullet”, “ammo”, etc).
   - Create “Casing” prefab using that mesh:
     - Rotate/scale so it looks like a casing. If the bullet is pointy, make it look like a sci-fi cartridge by scaling Y and adding slight metallic material (using existing materials in repo, no placeholder).
   - If materials are required and none exist, create a basic metallic material in-engine (real values: color, smoothness/roughness).

7) Sound system:
   - Create a WeaponSfxProvider that:
     - Given (weaponId, actionType, variantSeed) returns an AudioClip/AudioBuffer.
     - Caches generated clips.
   - Attach AudioSource/Emitter to players/weapons:
     - Fire sound plays at muzzle position.
     - Reload sound plays at weapon position (or player).
     - Casing impacts play at casing collision point.
   - Replication:
     - Fire: use WeaponFiredEvent to trigger fire sound on all clients.
     - Reload: replicate ReloadStartedEvent so others hear it.
   - Ensure volume rolloff/spatialization is configured so nearby players hear it and distant players don’t.

8) QA / Validation:
   - Add a debug command (or dev UI) that lists all WeaponIds and prints their definition values.
   - Add an automated validation/test that fails if:
     - any weapon lacks definition
     - any definition lacks required fields
     - any sound generation returns silence/zero samples
     - casing ejection enabled but casing prefab/mesh missing

DELIVERABLES (what you must commit/change):
- WeaponDefinition + WeaponDatabase/Registry
- Complete weapon entries for ALL weapons found in repo (and at least the defaults above)
- Updated weapon firing code to consume WeaponDefinition
- Server-synced WeaponFiredEvent that drives client VFX + casing + fire sound
- Casing prefab built from Blaster Kit bullet + pooling + collision impact sounds
- Procedural SFX generator integrated and used by WeaponDefinition sounds
- Minimal documentation in README or docs/WEAPONS.md describing:
  - how to add a new weapon definition
  - how casing replication works
  - how SFX generation works

OUTPUT FORMAT:
- Produce a coherent set of code changes across the repo.
- Prefer small, well-named files over one giant file.
- Keep code style consistent with repo.
- Do not leave the repo in a broken state. Everything must compile/run.

NOW IMPLEMENT IT.
