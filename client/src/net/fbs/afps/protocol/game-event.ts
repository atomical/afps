// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { FxEvent, unionToFxEvent, unionListToFxEvent } from '../../afps/protocol/fx-event.js';
import { HitConfirmedFx, HitConfirmedFxT } from '../../afps/protocol/hit-confirmed-fx.js';
import { KillFeedFx, KillFeedFxT } from '../../afps/protocol/kill-feed-fx.js';
import { NearMissFx, NearMissFxT } from '../../afps/protocol/near-miss-fx.js';
import { OverheatFx, OverheatFxT } from '../../afps/protocol/overheat-fx.js';
import { PickupSpawnedFx, PickupSpawnedFxT } from '../../afps/protocol/pickup-spawned-fx.js';
import { PickupTakenFx, PickupTakenFxT } from '../../afps/protocol/pickup-taken-fx.js';
import { ProjectileImpactFx, ProjectileImpactFxT } from '../../afps/protocol/projectile-impact-fx.js';
import { ProjectileRemoveFx, ProjectileRemoveFxT } from '../../afps/protocol/projectile-remove-fx.js';
import { ProjectileSpawnFx, ProjectileSpawnFxT } from '../../afps/protocol/projectile-spawn-fx.js';
import { ReloadFx, ReloadFxT } from '../../afps/protocol/reload-fx.js';
import { ShotFiredFx, ShotFiredFxT } from '../../afps/protocol/shot-fired-fx.js';
import { ShotTraceFx, ShotTraceFxT } from '../../afps/protocol/shot-trace-fx.js';
import { VentFx, VentFxT } from '../../afps/protocol/vent-fx.js';


export class GameEvent implements flatbuffers.IUnpackableObject<GameEventT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):GameEvent {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsGameEvent(bb:flatbuffers.ByteBuffer, obj?:GameEvent):GameEvent {
  return (obj || new GameEvent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsGameEvent(bb:flatbuffers.ByteBuffer, obj?:GameEvent):GameEvent {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameEvent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

serverTick():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

eventsType(index: number):FxEvent|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : null;
}

eventsTypeLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

eventsTypeArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

events(index: number, obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__union(obj, this.bb!.__vector(this.bb_pos + offset) + index * 4) : null;
}

eventsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startGameEvent(builder:flatbuffers.Builder) {
  builder.startObject(3);
}

static addServerTick(builder:flatbuffers.Builder, serverTick:number) {
  builder.addFieldInt32(0, serverTick, 0);
}

static addEventsType(builder:flatbuffers.Builder, eventsTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, eventsTypeOffset, 0);
}

static createEventsTypeVector(builder:flatbuffers.Builder, data:FxEvent[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startEventsTypeVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addEvents(builder:flatbuffers.Builder, eventsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, eventsOffset, 0);
}

static createEventsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEventsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endGameEvent(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createGameEvent(builder:flatbuffers.Builder, serverTick:number, eventsTypeOffset:flatbuffers.Offset, eventsOffset:flatbuffers.Offset):flatbuffers.Offset {
  GameEvent.startGameEvent(builder);
  GameEvent.addServerTick(builder, serverTick);
  GameEvent.addEventsType(builder, eventsTypeOffset);
  GameEvent.addEvents(builder, eventsOffset);
  return GameEvent.endGameEvent(builder);
}

unpack(): GameEventT {
  return new GameEventT(
    this.serverTick(),
    this.bb!.createScalarList<FxEvent>(this.eventsType.bind(this), this.eventsTypeLength()),
    (() => {
    const ret: (HitConfirmedFxT|KillFeedFxT|NearMissFxT|OverheatFxT|PickupSpawnedFxT|PickupTakenFxT|ProjectileImpactFxT|ProjectileRemoveFxT|ProjectileSpawnFxT|ReloadFxT|ShotFiredFxT|ShotTraceFxT|VentFxT)[] = [];
    for(let targetEnumIndex = 0; targetEnumIndex < this.eventsTypeLength(); ++targetEnumIndex) {
      const targetEnum = this.eventsType(targetEnumIndex);
      if(targetEnum === null || FxEvent[targetEnum!] === 'NONE') { continue; }

      const temp = unionListToFxEvent(targetEnum, this.events.bind(this), targetEnumIndex);
      if(temp === null) { continue; }
      ret.push(temp.unpack());
    }
    return ret;
  })()
  );
}


unpackTo(_o: GameEventT): void {
  _o.serverTick = this.serverTick();
  _o.eventsType = this.bb!.createScalarList<FxEvent>(this.eventsType.bind(this), this.eventsTypeLength());
  _o.events = (() => {
    const ret: (HitConfirmedFxT|KillFeedFxT|NearMissFxT|OverheatFxT|PickupSpawnedFxT|PickupTakenFxT|ProjectileImpactFxT|ProjectileRemoveFxT|ProjectileSpawnFxT|ReloadFxT|ShotFiredFxT|ShotTraceFxT|VentFxT)[] = [];
    for(let targetEnumIndex = 0; targetEnumIndex < this.eventsTypeLength(); ++targetEnumIndex) {
      const targetEnum = this.eventsType(targetEnumIndex);
      if(targetEnum === null || FxEvent[targetEnum!] === 'NONE') { continue; }

      const temp = unionListToFxEvent(targetEnum, this.events.bind(this), targetEnumIndex);
      if(temp === null) { continue; }
      ret.push(temp.unpack());
    }
    return ret;
  })();
}
}

export class GameEventT implements flatbuffers.IGeneratedObject {
constructor(
  public serverTick: number = 0,
  public eventsType: (FxEvent)[] = [],
  public events: (HitConfirmedFxT|KillFeedFxT|NearMissFxT|OverheatFxT|PickupSpawnedFxT|PickupTakenFxT|ProjectileImpactFxT|ProjectileRemoveFxT|ProjectileSpawnFxT|ReloadFxT|ShotFiredFxT|ShotTraceFxT|VentFxT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const eventsType = GameEvent.createEventsTypeVector(builder, this.eventsType);
  const events = GameEvent.createEventsVector(builder, builder.createObjectOffsetList(this.events));

  return GameEvent.createGameEvent(builder,
    this.serverTick,
    eventsType,
    events
  );
}
}
