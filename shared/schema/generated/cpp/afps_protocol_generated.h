// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AFPSPROTOCOL_AFPS_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_AFPSPROTOCOL_AFPS_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace afps {
namespace protocol {

struct ClientHello;
struct ClientHelloBuilder;
struct ClientHelloT;

struct ServerHello;
struct ServerHelloBuilder;
struct ServerHelloT;

struct JoinRequest;
struct JoinRequestBuilder;
struct JoinRequestT;

struct JoinAccept;
struct JoinAcceptBuilder;
struct JoinAcceptT;

struct InputCmd;
struct InputCmdBuilder;
struct InputCmdT;

struct FireWeaponRequest;
struct FireWeaponRequestBuilder;
struct FireWeaponRequestT;

struct WeaponFiredEvent;
struct WeaponFiredEventBuilder;
struct WeaponFiredEventT;

struct WeaponReloadEvent;
struct WeaponReloadEventBuilder;
struct WeaponReloadEventT;

struct StateSnapshot;
struct StateSnapshotBuilder;
struct StateSnapshotT;

struct StateSnapshotDelta;
struct StateSnapshotDeltaBuilder;
struct StateSnapshotDeltaT;

struct PlayerProfile;
struct PlayerProfileBuilder;
struct PlayerProfileT;

struct GameEvent;
struct GameEventBuilder;
struct GameEventT;

struct Ping;
struct PingBuilder;
struct PingT;

struct Pong;
struct PongBuilder;
struct PongT;

struct Error;
struct ErrorBuilder;
struct ErrorT;

struct Disconnect;
struct DisconnectBuilder;
struct DisconnectT;

enum class SchemaVersion : uint16_t {
  V1 = 1,
  MIN = V1,
  MAX = V1
};

inline const SchemaVersion (&EnumValuesSchemaVersion())[1] {
  static const SchemaVersion values[] = {
    SchemaVersion::V1
  };
  return values;
}

inline const char * const *EnumNamesSchemaVersion() {
  static const char * const names[2] = {
    "V1",
    nullptr
  };
  return names;
}

inline const char *EnumNameSchemaVersion(SchemaVersion e) {
  if (::flatbuffers::IsOutRange(e, SchemaVersion::V1, SchemaVersion::V1)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(SchemaVersion::V1);
  return EnumNamesSchemaVersion()[index];
}

enum class MessageType : uint16_t {
  ClientHello = 1,
  ServerHello = 2,
  JoinRequest = 3,
  JoinAccept = 4,
  InputCmd = 5,
  StateSnapshot = 6,
  StateSnapshotDelta = 7,
  GameEvent = 8,
  Ping = 9,
  Pong = 10,
  PlayerProfile = 11,
  Error = 12,
  Disconnect = 13,
  FireWeaponRequest = 14,
  WeaponFiredEvent = 15,
  WeaponReloadEvent = 16,
  MIN = ClientHello,
  MAX = WeaponReloadEvent
};

inline const MessageType (&EnumValuesMessageType())[16] {
  static const MessageType values[] = {
    MessageType::ClientHello,
    MessageType::ServerHello,
    MessageType::JoinRequest,
    MessageType::JoinAccept,
    MessageType::InputCmd,
    MessageType::StateSnapshot,
    MessageType::StateSnapshotDelta,
    MessageType::GameEvent,
    MessageType::Ping,
    MessageType::Pong,
    MessageType::PlayerProfile,
    MessageType::Error,
    MessageType::Disconnect,
    MessageType::FireWeaponRequest,
    MessageType::WeaponFiredEvent,
    MessageType::WeaponReloadEvent
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[17] = {
    "ClientHello",
    "ServerHello",
    "JoinRequest",
    "JoinAccept",
    "InputCmd",
    "StateSnapshot",
    "StateSnapshotDelta",
    "GameEvent",
    "Ping",
    "Pong",
    "PlayerProfile",
    "Error",
    "Disconnect",
    "FireWeaponRequest",
    "WeaponFiredEvent",
    "WeaponReloadEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType::ClientHello, MessageType::WeaponReloadEvent)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(MessageType::ClientHello);
  return EnumNamesMessageType()[index];
}

enum class GameEventType : int8_t {
  HitConfirmed = 0,
  ProjectileSpawn = 1,
  ProjectileRemove = 2,
  MIN = HitConfirmed,
  MAX = ProjectileRemove
};

inline const GameEventType (&EnumValuesGameEventType())[3] {
  static const GameEventType values[] = {
    GameEventType::HitConfirmed,
    GameEventType::ProjectileSpawn,
    GameEventType::ProjectileRemove
  };
  return values;
}

inline const char * const *EnumNamesGameEventType() {
  static const char * const names[4] = {
    "HitConfirmed",
    "ProjectileSpawn",
    "ProjectileRemove",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameEventType(GameEventType e) {
  if (::flatbuffers::IsOutRange(e, GameEventType::HitConfirmed, GameEventType::ProjectileRemove)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameEventType()[index];
}

struct ClientHelloT : public ::flatbuffers::NativeTable {
  typedef ClientHello TableType;
  uint16_t protocol_version = 0;
  std::string session_token{};
  std::string connection_id{};
  std::string build{};
  std::string nickname{};
  std::string character_id{};
};

struct ClientHello FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientHelloT NativeTableType;
  typedef ClientHelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_SESSION_TOKEN = 6,
    VT_CONNECTION_ID = 8,
    VT_BUILD = 10,
    VT_NICKNAME = 12,
    VT_CHARACTER_ID = 14
  };
  uint16_t protocol_version() const {
    return GetField<uint16_t>(VT_PROTOCOL_VERSION, 0);
  }
  const ::flatbuffers::String *session_token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_TOKEN);
  }
  const ::flatbuffers::String *connection_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONNECTION_ID);
  }
  const ::flatbuffers::String *build() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BUILD);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  const ::flatbuffers::String *character_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARACTER_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROTOCOL_VERSION, 2) &&
           VerifyOffset(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyString(session_token()) &&
           VerifyOffset(verifier, VT_CONNECTION_ID) &&
           verifier.VerifyString(connection_id()) &&
           VerifyOffset(verifier, VT_BUILD) &&
           verifier.VerifyString(build()) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           VerifyOffset(verifier, VT_CHARACTER_ID) &&
           verifier.VerifyString(character_id()) &&
           verifier.EndTable();
  }
  ClientHelloT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClientHelloT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ClientHello> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ClientHelloT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClientHelloBuilder {
  typedef ClientHello Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol_version(uint16_t protocol_version) {
    fbb_.AddElement<uint16_t>(ClientHello::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_session_token(::flatbuffers::Offset<::flatbuffers::String> session_token) {
    fbb_.AddOffset(ClientHello::VT_SESSION_TOKEN, session_token);
  }
  void add_connection_id(::flatbuffers::Offset<::flatbuffers::String> connection_id) {
    fbb_.AddOffset(ClientHello::VT_CONNECTION_ID, connection_id);
  }
  void add_build(::flatbuffers::Offset<::flatbuffers::String> build) {
    fbb_.AddOffset(ClientHello::VT_BUILD, build);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(ClientHello::VT_NICKNAME, nickname);
  }
  void add_character_id(::flatbuffers::Offset<::flatbuffers::String> character_id) {
    fbb_.AddOffset(ClientHello::VT_CHARACTER_ID, character_id);
  }
  explicit ClientHelloBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientHello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientHello>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientHello> CreateClientHello(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> session_token = 0,
    ::flatbuffers::Offset<::flatbuffers::String> connection_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> build = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> character_id = 0) {
  ClientHelloBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  builder_.add_nickname(nickname);
  builder_.add_build(build);
  builder_.add_connection_id(connection_id);
  builder_.add_session_token(session_token);
  builder_.add_protocol_version(protocol_version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ClientHello> CreateClientHelloDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol_version = 0,
    const char *session_token = nullptr,
    const char *connection_id = nullptr,
    const char *build = nullptr,
    const char *nickname = nullptr,
    const char *character_id = nullptr) {
  auto session_token__ = session_token ? _fbb.CreateString(session_token) : 0;
  auto connection_id__ = connection_id ? _fbb.CreateString(connection_id) : 0;
  auto build__ = build ? _fbb.CreateString(build) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  auto character_id__ = character_id ? _fbb.CreateString(character_id) : 0;
  return afps::protocol::CreateClientHello(
      _fbb,
      protocol_version,
      session_token__,
      connection_id__,
      build__,
      nickname__,
      character_id__);
}

::flatbuffers::Offset<ClientHello> CreateClientHello(::flatbuffers::FlatBufferBuilder &_fbb, const ClientHelloT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerHelloT : public ::flatbuffers::NativeTable {
  typedef ServerHello TableType;
  uint16_t protocol_version = 0;
  std::string connection_id{};
  std::string client_id{};
  uint16_t server_tick_rate = 0;
  uint16_t snapshot_rate = 0;
  uint16_t snapshot_keyframe_interval = 0;
  std::string motd{};
  std::string connection_nonce{};
};

struct ServerHello FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerHelloT NativeTableType;
  typedef ServerHelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_CONNECTION_ID = 6,
    VT_CLIENT_ID = 8,
    VT_SERVER_TICK_RATE = 10,
    VT_SNAPSHOT_RATE = 12,
    VT_SNAPSHOT_KEYFRAME_INTERVAL = 14,
    VT_MOTD = 16,
    VT_CONNECTION_NONCE = 18
  };
  uint16_t protocol_version() const {
    return GetField<uint16_t>(VT_PROTOCOL_VERSION, 0);
  }
  const ::flatbuffers::String *connection_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONNECTION_ID);
  }
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  uint16_t server_tick_rate() const {
    return GetField<uint16_t>(VT_SERVER_TICK_RATE, 0);
  }
  uint16_t snapshot_rate() const {
    return GetField<uint16_t>(VT_SNAPSHOT_RATE, 0);
  }
  uint16_t snapshot_keyframe_interval() const {
    return GetField<uint16_t>(VT_SNAPSHOT_KEYFRAME_INTERVAL, 0);
  }
  const ::flatbuffers::String *motd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MOTD);
  }
  const ::flatbuffers::String *connection_nonce() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONNECTION_NONCE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROTOCOL_VERSION, 2) &&
           VerifyOffset(verifier, VT_CONNECTION_ID) &&
           verifier.VerifyString(connection_id()) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyField<uint16_t>(verifier, VT_SERVER_TICK_RATE, 2) &&
           VerifyField<uint16_t>(verifier, VT_SNAPSHOT_RATE, 2) &&
           VerifyField<uint16_t>(verifier, VT_SNAPSHOT_KEYFRAME_INTERVAL, 2) &&
           VerifyOffset(verifier, VT_MOTD) &&
           verifier.VerifyString(motd()) &&
           VerifyOffset(verifier, VT_CONNECTION_NONCE) &&
           verifier.VerifyString(connection_nonce()) &&
           verifier.EndTable();
  }
  ServerHelloT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerHelloT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ServerHello> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ServerHelloT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerHelloBuilder {
  typedef ServerHello Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol_version(uint16_t protocol_version) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_connection_id(::flatbuffers::Offset<::flatbuffers::String> connection_id) {
    fbb_.AddOffset(ServerHello::VT_CONNECTION_ID, connection_id);
  }
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(ServerHello::VT_CLIENT_ID, client_id);
  }
  void add_server_tick_rate(uint16_t server_tick_rate) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_SERVER_TICK_RATE, server_tick_rate, 0);
  }
  void add_snapshot_rate(uint16_t snapshot_rate) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_SNAPSHOT_RATE, snapshot_rate, 0);
  }
  void add_snapshot_keyframe_interval(uint16_t snapshot_keyframe_interval) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_SNAPSHOT_KEYFRAME_INTERVAL, snapshot_keyframe_interval, 0);
  }
  void add_motd(::flatbuffers::Offset<::flatbuffers::String> motd) {
    fbb_.AddOffset(ServerHello::VT_MOTD, motd);
  }
  void add_connection_nonce(::flatbuffers::Offset<::flatbuffers::String> connection_nonce) {
    fbb_.AddOffset(ServerHello::VT_CONNECTION_NONCE, connection_nonce);
  }
  explicit ServerHelloBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerHello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerHello>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerHello> CreateServerHello(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> connection_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    uint16_t server_tick_rate = 0,
    uint16_t snapshot_rate = 0,
    uint16_t snapshot_keyframe_interval = 0,
    ::flatbuffers::Offset<::flatbuffers::String> motd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> connection_nonce = 0) {
  ServerHelloBuilder builder_(_fbb);
  builder_.add_connection_nonce(connection_nonce);
  builder_.add_motd(motd);
  builder_.add_client_id(client_id);
  builder_.add_connection_id(connection_id);
  builder_.add_snapshot_keyframe_interval(snapshot_keyframe_interval);
  builder_.add_snapshot_rate(snapshot_rate);
  builder_.add_server_tick_rate(server_tick_rate);
  builder_.add_protocol_version(protocol_version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ServerHello> CreateServerHelloDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol_version = 0,
    const char *connection_id = nullptr,
    const char *client_id = nullptr,
    uint16_t server_tick_rate = 0,
    uint16_t snapshot_rate = 0,
    uint16_t snapshot_keyframe_interval = 0,
    const char *motd = nullptr,
    const char *connection_nonce = nullptr) {
  auto connection_id__ = connection_id ? _fbb.CreateString(connection_id) : 0;
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  auto motd__ = motd ? _fbb.CreateString(motd) : 0;
  auto connection_nonce__ = connection_nonce ? _fbb.CreateString(connection_nonce) : 0;
  return afps::protocol::CreateServerHello(
      _fbb,
      protocol_version,
      connection_id__,
      client_id__,
      server_tick_rate,
      snapshot_rate,
      snapshot_keyframe_interval,
      motd__,
      connection_nonce__);
}

::flatbuffers::Offset<ServerHello> CreateServerHello(::flatbuffers::FlatBufferBuilder &_fbb, const ServerHelloT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinRequestT : public ::flatbuffers::NativeTable {
  typedef JoinRequest TableType;
  std::string nickname{};
  std::string character_id{};
};

struct JoinRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinRequestT NativeTableType;
  typedef JoinRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NICKNAME = 4,
    VT_CHARACTER_ID = 6
  };
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  const ::flatbuffers::String *character_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARACTER_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           VerifyOffset(verifier, VT_CHARACTER_ID) &&
           verifier.VerifyString(character_id()) &&
           verifier.EndTable();
  }
  JoinRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<JoinRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinRequestBuilder {
  typedef JoinRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(JoinRequest::VT_NICKNAME, nickname);
  }
  void add_character_id(::flatbuffers::Offset<::flatbuffers::String> character_id) {
    fbb_.AddOffset(JoinRequest::VT_CHARACTER_ID, character_id);
  }
  explicit JoinRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinRequest> CreateJoinRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> character_id = 0) {
  JoinRequestBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  builder_.add_nickname(nickname);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JoinRequest> CreateJoinRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *nickname = nullptr,
    const char *character_id = nullptr) {
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  auto character_id__ = character_id ? _fbb.CreateString(character_id) : 0;
  return afps::protocol::CreateJoinRequest(
      _fbb,
      nickname__,
      character_id__);
}

::flatbuffers::Offset<JoinRequest> CreateJoinRequest(::flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinAcceptT : public ::flatbuffers::NativeTable {
  typedef JoinAccept TableType;
  std::string client_id{};
};

struct JoinAccept FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinAcceptT NativeTableType;
  typedef JoinAcceptBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ID = 4
  };
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           verifier.EndTable();
  }
  JoinAcceptT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinAcceptT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<JoinAccept> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoinAcceptT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinAcceptBuilder {
  typedef JoinAccept Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(JoinAccept::VT_CLIENT_ID, client_id);
  }
  explicit JoinAcceptBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinAccept> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinAccept>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinAccept> CreateJoinAccept(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0) {
  JoinAcceptBuilder builder_(_fbb);
  builder_.add_client_id(client_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JoinAccept> CreateJoinAcceptDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *client_id = nullptr) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  return afps::protocol::CreateJoinAccept(
      _fbb,
      client_id__);
}

::flatbuffers::Offset<JoinAccept> CreateJoinAccept(::flatbuffers::FlatBufferBuilder &_fbb, const JoinAcceptT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputCmdT : public ::flatbuffers::NativeTable {
  typedef InputCmd TableType;
  int32_t input_seq = 0;
  double move_x = 0.0;
  double move_y = 0.0;
  double look_delta_x = 0.0;
  double look_delta_y = 0.0;
  double view_yaw = 0.0;
  double view_pitch = 0.0;
  int32_t weapon_slot = 0;
  bool jump = false;
  bool fire = false;
  bool sprint = false;
  bool dash = false;
  bool grapple = false;
  bool shield = false;
  bool shockwave = false;
};

struct InputCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InputCmdT NativeTableType;
  typedef InputCmdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_SEQ = 4,
    VT_MOVE_X = 6,
    VT_MOVE_Y = 8,
    VT_LOOK_DELTA_X = 10,
    VT_LOOK_DELTA_Y = 12,
    VT_VIEW_YAW = 14,
    VT_VIEW_PITCH = 16,
    VT_WEAPON_SLOT = 18,
    VT_JUMP = 20,
    VT_FIRE = 22,
    VT_SPRINT = 24,
    VT_DASH = 26,
    VT_GRAPPLE = 28,
    VT_SHIELD = 30,
    VT_SHOCKWAVE = 32
  };
  int32_t input_seq() const {
    return GetField<int32_t>(VT_INPUT_SEQ, 0);
  }
  double move_x() const {
    return GetField<double>(VT_MOVE_X, 0.0);
  }
  double move_y() const {
    return GetField<double>(VT_MOVE_Y, 0.0);
  }
  double look_delta_x() const {
    return GetField<double>(VT_LOOK_DELTA_X, 0.0);
  }
  double look_delta_y() const {
    return GetField<double>(VT_LOOK_DELTA_Y, 0.0);
  }
  double view_yaw() const {
    return GetField<double>(VT_VIEW_YAW, 0.0);
  }
  double view_pitch() const {
    return GetField<double>(VT_VIEW_PITCH, 0.0);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  bool jump() const {
    return GetField<uint8_t>(VT_JUMP, 0) != 0;
  }
  bool fire() const {
    return GetField<uint8_t>(VT_FIRE, 0) != 0;
  }
  bool sprint() const {
    return GetField<uint8_t>(VT_SPRINT, 0) != 0;
  }
  bool dash() const {
    return GetField<uint8_t>(VT_DASH, 0) != 0;
  }
  bool grapple() const {
    return GetField<uint8_t>(VT_GRAPPLE, 0) != 0;
  }
  bool shield() const {
    return GetField<uint8_t>(VT_SHIELD, 0) != 0;
  }
  bool shockwave() const {
    return GetField<uint8_t>(VT_SHOCKWAVE, 0) != 0;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INPUT_SEQ, 4) &&
           VerifyField<double>(verifier, VT_MOVE_X, 8) &&
           VerifyField<double>(verifier, VT_MOVE_Y, 8) &&
           VerifyField<double>(verifier, VT_LOOK_DELTA_X, 8) &&
           VerifyField<double>(verifier, VT_LOOK_DELTA_Y, 8) &&
           VerifyField<double>(verifier, VT_VIEW_YAW, 8) &&
           VerifyField<double>(verifier, VT_VIEW_PITCH, 8) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<uint8_t>(verifier, VT_JUMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_FIRE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SPRINT, 1) &&
           VerifyField<uint8_t>(verifier, VT_DASH, 1) &&
           VerifyField<uint8_t>(verifier, VT_GRAPPLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHIELD, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHOCKWAVE, 1) &&
           verifier.EndTable();
  }
  InputCmdT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputCmdT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<InputCmd> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InputCmdT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputCmdBuilder {
  typedef InputCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_seq(int32_t input_seq) {
    fbb_.AddElement<int32_t>(InputCmd::VT_INPUT_SEQ, input_seq, 0);
  }
  void add_move_x(double move_x) {
    fbb_.AddElement<double>(InputCmd::VT_MOVE_X, move_x, 0.0);
  }
  void add_move_y(double move_y) {
    fbb_.AddElement<double>(InputCmd::VT_MOVE_Y, move_y, 0.0);
  }
  void add_look_delta_x(double look_delta_x) {
    fbb_.AddElement<double>(InputCmd::VT_LOOK_DELTA_X, look_delta_x, 0.0);
  }
  void add_look_delta_y(double look_delta_y) {
    fbb_.AddElement<double>(InputCmd::VT_LOOK_DELTA_Y, look_delta_y, 0.0);
  }
  void add_view_yaw(double view_yaw) {
    fbb_.AddElement<double>(InputCmd::VT_VIEW_YAW, view_yaw, 0.0);
  }
  void add_view_pitch(double view_pitch) {
    fbb_.AddElement<double>(InputCmd::VT_VIEW_PITCH, view_pitch, 0.0);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(InputCmd::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_jump(bool jump) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_JUMP, static_cast<uint8_t>(jump), 0);
  }
  void add_fire(bool fire) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_FIRE, static_cast<uint8_t>(fire), 0);
  }
  void add_sprint(bool sprint) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_SPRINT, static_cast<uint8_t>(sprint), 0);
  }
  void add_dash(bool dash) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_DASH, static_cast<uint8_t>(dash), 0);
  }
  void add_grapple(bool grapple) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_GRAPPLE, static_cast<uint8_t>(grapple), 0);
  }
  void add_shield(bool shield) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_SHIELD, static_cast<uint8_t>(shield), 0);
  }
  void add_shockwave(bool shockwave) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_SHOCKWAVE, static_cast<uint8_t>(shockwave), 0);
  }
  explicit InputCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InputCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InputCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InputCmd> CreateInputCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t input_seq = 0,
    double move_x = 0.0,
    double move_y = 0.0,
    double look_delta_x = 0.0,
    double look_delta_y = 0.0,
    double view_yaw = 0.0,
    double view_pitch = 0.0,
    int32_t weapon_slot = 0,
    bool jump = false,
    bool fire = false,
    bool sprint = false,
    bool dash = false,
    bool grapple = false,
    bool shield = false,
    bool shockwave = false) {
  InputCmdBuilder builder_(_fbb);
  builder_.add_view_pitch(view_pitch);
  builder_.add_view_yaw(view_yaw);
  builder_.add_look_delta_y(look_delta_y);
  builder_.add_look_delta_x(look_delta_x);
  builder_.add_move_y(move_y);
  builder_.add_move_x(move_x);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_input_seq(input_seq);
  builder_.add_shockwave(shockwave);
  builder_.add_shield(shield);
  builder_.add_grapple(grapple);
  builder_.add_dash(dash);
  builder_.add_sprint(sprint);
  builder_.add_fire(fire);
  builder_.add_jump(jump);
  return builder_.Finish();
}

::flatbuffers::Offset<InputCmd> CreateInputCmd(::flatbuffers::FlatBufferBuilder &_fbb, const InputCmdT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FireWeaponRequestT : public ::flatbuffers::NativeTable {
  typedef FireWeaponRequest TableType;
  int32_t client_shot_seq = 0;
  std::string weapon_id{};
  int32_t weapon_slot = 0;
  double origin_x = 0.0;
  double origin_y = 0.0;
  double origin_z = 0.0;
  double dir_x = 0.0;
  double dir_y = 0.0;
  double dir_z = 0.0;
};

struct FireWeaponRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FireWeaponRequestT NativeTableType;
  typedef FireWeaponRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_SHOT_SEQ = 4,
    VT_WEAPON_ID = 6,
    VT_WEAPON_SLOT = 8,
    VT_ORIGIN_X = 10,
    VT_ORIGIN_Y = 12,
    VT_ORIGIN_Z = 14,
    VT_DIR_X = 16,
    VT_DIR_Y = 18,
    VT_DIR_Z = 20
  };
  int32_t client_shot_seq() const {
    return GetField<int32_t>(VT_CLIENT_SHOT_SEQ, 0);
  }
  const ::flatbuffers::String *weapon_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEAPON_ID);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  double origin_x() const {
    return GetField<double>(VT_ORIGIN_X, 0.0);
  }
  double origin_y() const {
    return GetField<double>(VT_ORIGIN_Y, 0.0);
  }
  double origin_z() const {
    return GetField<double>(VT_ORIGIN_Z, 0.0);
  }
  double dir_x() const {
    return GetField<double>(VT_DIR_X, 0.0);
  }
  double dir_y() const {
    return GetField<double>(VT_DIR_Y, 0.0);
  }
  double dir_z() const {
    return GetField<double>(VT_DIR_Z, 0.0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLIENT_SHOT_SEQ, 4) &&
           VerifyOffset(verifier, VT_WEAPON_ID) &&
           verifier.VerifyString(weapon_id()) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<double>(verifier, VT_ORIGIN_X, 8) &&
           VerifyField<double>(verifier, VT_ORIGIN_Y, 8) &&
           VerifyField<double>(verifier, VT_ORIGIN_Z, 8) &&
           VerifyField<double>(verifier, VT_DIR_X, 8) &&
           VerifyField<double>(verifier, VT_DIR_Y, 8) &&
           VerifyField<double>(verifier, VT_DIR_Z, 8) &&
           verifier.EndTable();
  }
  FireWeaponRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FireWeaponRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FireWeaponRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FireWeaponRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FireWeaponRequestBuilder {
  typedef FireWeaponRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_shot_seq(int32_t client_shot_seq) {
    fbb_.AddElement<int32_t>(FireWeaponRequest::VT_CLIENT_SHOT_SEQ, client_shot_seq, 0);
  }
  void add_weapon_id(::flatbuffers::Offset<::flatbuffers::String> weapon_id) {
    fbb_.AddOffset(FireWeaponRequest::VT_WEAPON_ID, weapon_id);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(FireWeaponRequest::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_origin_x(double origin_x) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_ORIGIN_X, origin_x, 0.0);
  }
  void add_origin_y(double origin_y) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_ORIGIN_Y, origin_y, 0.0);
  }
  void add_origin_z(double origin_z) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_ORIGIN_Z, origin_z, 0.0);
  }
  void add_dir_x(double dir_x) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_DIR_X, dir_x, 0.0);
  }
  void add_dir_y(double dir_y) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_DIR_Y, dir_y, 0.0);
  }
  void add_dir_z(double dir_z) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_DIR_Z, dir_z, 0.0);
  }
  explicit FireWeaponRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FireWeaponRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FireWeaponRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FireWeaponRequest> CreateFireWeaponRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t client_shot_seq = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weapon_id = 0,
    int32_t weapon_slot = 0,
    double origin_x = 0.0,
    double origin_y = 0.0,
    double origin_z = 0.0,
    double dir_x = 0.0,
    double dir_y = 0.0,
    double dir_z = 0.0) {
  FireWeaponRequestBuilder builder_(_fbb);
  builder_.add_dir_z(dir_z);
  builder_.add_dir_y(dir_y);
  builder_.add_dir_x(dir_x);
  builder_.add_origin_z(origin_z);
  builder_.add_origin_y(origin_y);
  builder_.add_origin_x(origin_x);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_weapon_id(weapon_id);
  builder_.add_client_shot_seq(client_shot_seq);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FireWeaponRequest> CreateFireWeaponRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t client_shot_seq = 0,
    const char *weapon_id = nullptr,
    int32_t weapon_slot = 0,
    double origin_x = 0.0,
    double origin_y = 0.0,
    double origin_z = 0.0,
    double dir_x = 0.0,
    double dir_y = 0.0,
    double dir_z = 0.0) {
  auto weapon_id__ = weapon_id ? _fbb.CreateString(weapon_id) : 0;
  return afps::protocol::CreateFireWeaponRequest(
      _fbb,
      client_shot_seq,
      weapon_id__,
      weapon_slot,
      origin_x,
      origin_y,
      origin_z,
      dir_x,
      dir_y,
      dir_z);
}

::flatbuffers::Offset<FireWeaponRequest> CreateFireWeaponRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FireWeaponRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WeaponFiredEventT : public ::flatbuffers::NativeTable {
  typedef WeaponFiredEvent TableType;
  std::string shooter_id{};
  std::string weapon_id{};
  int32_t weapon_slot = 0;
  int32_t server_tick = 0;
  int32_t shot_seq = 0;
  double muzzle_pos_x = 0.0;
  double muzzle_pos_y = 0.0;
  double muzzle_pos_z = 0.0;
  double dir_x = 0.0;
  double dir_y = 0.0;
  double dir_z = 0.0;
  bool dry_fire = false;
  bool casing_enabled = false;
  double casing_pos_x = 0.0;
  double casing_pos_y = 0.0;
  double casing_pos_z = 0.0;
  double casing_rot_x = 0.0;
  double casing_rot_y = 0.0;
  double casing_rot_z = 0.0;
  double casing_vel_x = 0.0;
  double casing_vel_y = 0.0;
  double casing_vel_z = 0.0;
  double casing_ang_x = 0.0;
  double casing_ang_y = 0.0;
  double casing_ang_z = 0.0;
  uint32_t casing_seed = 0;
};

struct WeaponFiredEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WeaponFiredEventT NativeTableType;
  typedef WeaponFiredEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_WEAPON_ID = 6,
    VT_WEAPON_SLOT = 8,
    VT_SERVER_TICK = 10,
    VT_SHOT_SEQ = 12,
    VT_MUZZLE_POS_X = 14,
    VT_MUZZLE_POS_Y = 16,
    VT_MUZZLE_POS_Z = 18,
    VT_DIR_X = 20,
    VT_DIR_Y = 22,
    VT_DIR_Z = 24,
    VT_DRY_FIRE = 26,
    VT_CASING_ENABLED = 28,
    VT_CASING_POS_X = 30,
    VT_CASING_POS_Y = 32,
    VT_CASING_POS_Z = 34,
    VT_CASING_ROT_X = 36,
    VT_CASING_ROT_Y = 38,
    VT_CASING_ROT_Z = 40,
    VT_CASING_VEL_X = 42,
    VT_CASING_VEL_Y = 44,
    VT_CASING_VEL_Z = 46,
    VT_CASING_ANG_X = 48,
    VT_CASING_ANG_Y = 50,
    VT_CASING_ANG_Z = 52,
    VT_CASING_SEED = 54
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  const ::flatbuffers::String *weapon_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEAPON_ID);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  int32_t shot_seq() const {
    return GetField<int32_t>(VT_SHOT_SEQ, 0);
  }
  double muzzle_pos_x() const {
    return GetField<double>(VT_MUZZLE_POS_X, 0.0);
  }
  double muzzle_pos_y() const {
    return GetField<double>(VT_MUZZLE_POS_Y, 0.0);
  }
  double muzzle_pos_z() const {
    return GetField<double>(VT_MUZZLE_POS_Z, 0.0);
  }
  double dir_x() const {
    return GetField<double>(VT_DIR_X, 0.0);
  }
  double dir_y() const {
    return GetField<double>(VT_DIR_Y, 0.0);
  }
  double dir_z() const {
    return GetField<double>(VT_DIR_Z, 0.0);
  }
  bool dry_fire() const {
    return GetField<uint8_t>(VT_DRY_FIRE, 0) != 0;
  }
  bool casing_enabled() const {
    return GetField<uint8_t>(VT_CASING_ENABLED, 0) != 0;
  }
  double casing_pos_x() const {
    return GetField<double>(VT_CASING_POS_X, 0.0);
  }
  double casing_pos_y() const {
    return GetField<double>(VT_CASING_POS_Y, 0.0);
  }
  double casing_pos_z() const {
    return GetField<double>(VT_CASING_POS_Z, 0.0);
  }
  double casing_rot_x() const {
    return GetField<double>(VT_CASING_ROT_X, 0.0);
  }
  double casing_rot_y() const {
    return GetField<double>(VT_CASING_ROT_Y, 0.0);
  }
  double casing_rot_z() const {
    return GetField<double>(VT_CASING_ROT_Z, 0.0);
  }
  double casing_vel_x() const {
    return GetField<double>(VT_CASING_VEL_X, 0.0);
  }
  double casing_vel_y() const {
    return GetField<double>(VT_CASING_VEL_Y, 0.0);
  }
  double casing_vel_z() const {
    return GetField<double>(VT_CASING_VEL_Z, 0.0);
  }
  double casing_ang_x() const {
    return GetField<double>(VT_CASING_ANG_X, 0.0);
  }
  double casing_ang_y() const {
    return GetField<double>(VT_CASING_ANG_Y, 0.0);
  }
  double casing_ang_z() const {
    return GetField<double>(VT_CASING_ANG_Z, 0.0);
  }
  uint32_t casing_seed() const {
    return GetField<uint32_t>(VT_CASING_SEED, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyOffset(verifier, VT_WEAPON_ID) &&
           verifier.VerifyString(weapon_id()) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           VerifyField<int32_t>(verifier, VT_SHOT_SEQ, 4) &&
           VerifyField<double>(verifier, VT_MUZZLE_POS_X, 8) &&
           VerifyField<double>(verifier, VT_MUZZLE_POS_Y, 8) &&
           VerifyField<double>(verifier, VT_MUZZLE_POS_Z, 8) &&
           VerifyField<double>(verifier, VT_DIR_X, 8) &&
           VerifyField<double>(verifier, VT_DIR_Y, 8) &&
           VerifyField<double>(verifier, VT_DIR_Z, 8) &&
           VerifyField<uint8_t>(verifier, VT_DRY_FIRE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CASING_ENABLED, 1) &&
           VerifyField<double>(verifier, VT_CASING_POS_X, 8) &&
           VerifyField<double>(verifier, VT_CASING_POS_Y, 8) &&
           VerifyField<double>(verifier, VT_CASING_POS_Z, 8) &&
           VerifyField<double>(verifier, VT_CASING_ROT_X, 8) &&
           VerifyField<double>(verifier, VT_CASING_ROT_Y, 8) &&
           VerifyField<double>(verifier, VT_CASING_ROT_Z, 8) &&
           VerifyField<double>(verifier, VT_CASING_VEL_X, 8) &&
           VerifyField<double>(verifier, VT_CASING_VEL_Y, 8) &&
           VerifyField<double>(verifier, VT_CASING_VEL_Z, 8) &&
           VerifyField<double>(verifier, VT_CASING_ANG_X, 8) &&
           VerifyField<double>(verifier, VT_CASING_ANG_Y, 8) &&
           VerifyField<double>(verifier, VT_CASING_ANG_Z, 8) &&
           VerifyField<uint32_t>(verifier, VT_CASING_SEED, 4) &&
           verifier.EndTable();
  }
  WeaponFiredEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WeaponFiredEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WeaponFiredEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WeaponFiredEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WeaponFiredEventBuilder {
  typedef WeaponFiredEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(WeaponFiredEvent::VT_SHOOTER_ID, shooter_id);
  }
  void add_weapon_id(::flatbuffers::Offset<::flatbuffers::String> weapon_id) {
    fbb_.AddOffset(WeaponFiredEvent::VT_WEAPON_ID, weapon_id);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(WeaponFiredEvent::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(WeaponFiredEvent::VT_SERVER_TICK, server_tick, 0);
  }
  void add_shot_seq(int32_t shot_seq) {
    fbb_.AddElement<int32_t>(WeaponFiredEvent::VT_SHOT_SEQ, shot_seq, 0);
  }
  void add_muzzle_pos_x(double muzzle_pos_x) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_MUZZLE_POS_X, muzzle_pos_x, 0.0);
  }
  void add_muzzle_pos_y(double muzzle_pos_y) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_MUZZLE_POS_Y, muzzle_pos_y, 0.0);
  }
  void add_muzzle_pos_z(double muzzle_pos_z) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_MUZZLE_POS_Z, muzzle_pos_z, 0.0);
  }
  void add_dir_x(double dir_x) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_DIR_X, dir_x, 0.0);
  }
  void add_dir_y(double dir_y) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_DIR_Y, dir_y, 0.0);
  }
  void add_dir_z(double dir_z) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_DIR_Z, dir_z, 0.0);
  }
  void add_dry_fire(bool dry_fire) {
    fbb_.AddElement<uint8_t>(WeaponFiredEvent::VT_DRY_FIRE, static_cast<uint8_t>(dry_fire), 0);
  }
  void add_casing_enabled(bool casing_enabled) {
    fbb_.AddElement<uint8_t>(WeaponFiredEvent::VT_CASING_ENABLED, static_cast<uint8_t>(casing_enabled), 0);
  }
  void add_casing_pos_x(double casing_pos_x) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_POS_X, casing_pos_x, 0.0);
  }
  void add_casing_pos_y(double casing_pos_y) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_POS_Y, casing_pos_y, 0.0);
  }
  void add_casing_pos_z(double casing_pos_z) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_POS_Z, casing_pos_z, 0.0);
  }
  void add_casing_rot_x(double casing_rot_x) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_ROT_X, casing_rot_x, 0.0);
  }
  void add_casing_rot_y(double casing_rot_y) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_ROT_Y, casing_rot_y, 0.0);
  }
  void add_casing_rot_z(double casing_rot_z) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_ROT_Z, casing_rot_z, 0.0);
  }
  void add_casing_vel_x(double casing_vel_x) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_VEL_X, casing_vel_x, 0.0);
  }
  void add_casing_vel_y(double casing_vel_y) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_VEL_Y, casing_vel_y, 0.0);
  }
  void add_casing_vel_z(double casing_vel_z) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_VEL_Z, casing_vel_z, 0.0);
  }
  void add_casing_ang_x(double casing_ang_x) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_ANG_X, casing_ang_x, 0.0);
  }
  void add_casing_ang_y(double casing_ang_y) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_ANG_Y, casing_ang_y, 0.0);
  }
  void add_casing_ang_z(double casing_ang_z) {
    fbb_.AddElement<double>(WeaponFiredEvent::VT_CASING_ANG_Z, casing_ang_z, 0.0);
  }
  void add_casing_seed(uint32_t casing_seed) {
    fbb_.AddElement<uint32_t>(WeaponFiredEvent::VT_CASING_SEED, casing_seed, 0);
  }
  explicit WeaponFiredEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WeaponFiredEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WeaponFiredEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WeaponFiredEvent> CreateWeaponFiredEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weapon_id = 0,
    int32_t weapon_slot = 0,
    int32_t server_tick = 0,
    int32_t shot_seq = 0,
    double muzzle_pos_x = 0.0,
    double muzzle_pos_y = 0.0,
    double muzzle_pos_z = 0.0,
    double dir_x = 0.0,
    double dir_y = 0.0,
    double dir_z = 0.0,
    bool dry_fire = false,
    bool casing_enabled = false,
    double casing_pos_x = 0.0,
    double casing_pos_y = 0.0,
    double casing_pos_z = 0.0,
    double casing_rot_x = 0.0,
    double casing_rot_y = 0.0,
    double casing_rot_z = 0.0,
    double casing_vel_x = 0.0,
    double casing_vel_y = 0.0,
    double casing_vel_z = 0.0,
    double casing_ang_x = 0.0,
    double casing_ang_y = 0.0,
    double casing_ang_z = 0.0,
    uint32_t casing_seed = 0) {
  WeaponFiredEventBuilder builder_(_fbb);
  builder_.add_casing_ang_z(casing_ang_z);
  builder_.add_casing_ang_y(casing_ang_y);
  builder_.add_casing_ang_x(casing_ang_x);
  builder_.add_casing_vel_z(casing_vel_z);
  builder_.add_casing_vel_y(casing_vel_y);
  builder_.add_casing_vel_x(casing_vel_x);
  builder_.add_casing_rot_z(casing_rot_z);
  builder_.add_casing_rot_y(casing_rot_y);
  builder_.add_casing_rot_x(casing_rot_x);
  builder_.add_casing_pos_z(casing_pos_z);
  builder_.add_casing_pos_y(casing_pos_y);
  builder_.add_casing_pos_x(casing_pos_x);
  builder_.add_dir_z(dir_z);
  builder_.add_dir_y(dir_y);
  builder_.add_dir_x(dir_x);
  builder_.add_muzzle_pos_z(muzzle_pos_z);
  builder_.add_muzzle_pos_y(muzzle_pos_y);
  builder_.add_muzzle_pos_x(muzzle_pos_x);
  builder_.add_casing_seed(casing_seed);
  builder_.add_shot_seq(shot_seq);
  builder_.add_server_tick(server_tick);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_weapon_id(weapon_id);
  builder_.add_shooter_id(shooter_id);
  builder_.add_casing_enabled(casing_enabled);
  builder_.add_dry_fire(dry_fire);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WeaponFiredEvent> CreateWeaponFiredEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    const char *weapon_id = nullptr,
    int32_t weapon_slot = 0,
    int32_t server_tick = 0,
    int32_t shot_seq = 0,
    double muzzle_pos_x = 0.0,
    double muzzle_pos_y = 0.0,
    double muzzle_pos_z = 0.0,
    double dir_x = 0.0,
    double dir_y = 0.0,
    double dir_z = 0.0,
    bool dry_fire = false,
    bool casing_enabled = false,
    double casing_pos_x = 0.0,
    double casing_pos_y = 0.0,
    double casing_pos_z = 0.0,
    double casing_rot_x = 0.0,
    double casing_rot_y = 0.0,
    double casing_rot_z = 0.0,
    double casing_vel_x = 0.0,
    double casing_vel_y = 0.0,
    double casing_vel_z = 0.0,
    double casing_ang_x = 0.0,
    double casing_ang_y = 0.0,
    double casing_ang_z = 0.0,
    uint32_t casing_seed = 0) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  auto weapon_id__ = weapon_id ? _fbb.CreateString(weapon_id) : 0;
  return afps::protocol::CreateWeaponFiredEvent(
      _fbb,
      shooter_id__,
      weapon_id__,
      weapon_slot,
      server_tick,
      shot_seq,
      muzzle_pos_x,
      muzzle_pos_y,
      muzzle_pos_z,
      dir_x,
      dir_y,
      dir_z,
      dry_fire,
      casing_enabled,
      casing_pos_x,
      casing_pos_y,
      casing_pos_z,
      casing_rot_x,
      casing_rot_y,
      casing_rot_z,
      casing_vel_x,
      casing_vel_y,
      casing_vel_z,
      casing_ang_x,
      casing_ang_y,
      casing_ang_z,
      casing_seed);
}

::flatbuffers::Offset<WeaponFiredEvent> CreateWeaponFiredEvent(::flatbuffers::FlatBufferBuilder &_fbb, const WeaponFiredEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WeaponReloadEventT : public ::flatbuffers::NativeTable {
  typedef WeaponReloadEvent TableType;
  std::string shooter_id{};
  std::string weapon_id{};
  int32_t weapon_slot = 0;
  int32_t server_tick = 0;
  double reload_seconds = 0.0;
};

struct WeaponReloadEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WeaponReloadEventT NativeTableType;
  typedef WeaponReloadEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_WEAPON_ID = 6,
    VT_WEAPON_SLOT = 8,
    VT_SERVER_TICK = 10,
    VT_RELOAD_SECONDS = 12
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  const ::flatbuffers::String *weapon_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEAPON_ID);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  double reload_seconds() const {
    return GetField<double>(VT_RELOAD_SECONDS, 0.0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyOffset(verifier, VT_WEAPON_ID) &&
           verifier.VerifyString(weapon_id()) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           VerifyField<double>(verifier, VT_RELOAD_SECONDS, 8) &&
           verifier.EndTable();
  }
  WeaponReloadEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WeaponReloadEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WeaponReloadEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WeaponReloadEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WeaponReloadEventBuilder {
  typedef WeaponReloadEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(WeaponReloadEvent::VT_SHOOTER_ID, shooter_id);
  }
  void add_weapon_id(::flatbuffers::Offset<::flatbuffers::String> weapon_id) {
    fbb_.AddOffset(WeaponReloadEvent::VT_WEAPON_ID, weapon_id);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(WeaponReloadEvent::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(WeaponReloadEvent::VT_SERVER_TICK, server_tick, 0);
  }
  void add_reload_seconds(double reload_seconds) {
    fbb_.AddElement<double>(WeaponReloadEvent::VT_RELOAD_SECONDS, reload_seconds, 0.0);
  }
  explicit WeaponReloadEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WeaponReloadEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WeaponReloadEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WeaponReloadEvent> CreateWeaponReloadEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weapon_id = 0,
    int32_t weapon_slot = 0,
    int32_t server_tick = 0,
    double reload_seconds = 0.0) {
  WeaponReloadEventBuilder builder_(_fbb);
  builder_.add_reload_seconds(reload_seconds);
  builder_.add_server_tick(server_tick);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_weapon_id(weapon_id);
  builder_.add_shooter_id(shooter_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WeaponReloadEvent> CreateWeaponReloadEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    const char *weapon_id = nullptr,
    int32_t weapon_slot = 0,
    int32_t server_tick = 0,
    double reload_seconds = 0.0) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  auto weapon_id__ = weapon_id ? _fbb.CreateString(weapon_id) : 0;
  return afps::protocol::CreateWeaponReloadEvent(
      _fbb,
      shooter_id__,
      weapon_id__,
      weapon_slot,
      server_tick,
      reload_seconds);
}

::flatbuffers::Offset<WeaponReloadEvent> CreateWeaponReloadEvent(::flatbuffers::FlatBufferBuilder &_fbb, const WeaponReloadEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateSnapshotT : public ::flatbuffers::NativeTable {
  typedef StateSnapshot TableType;
  int32_t server_tick = 0;
  int32_t last_processed_input_seq = 0;
  std::string client_id{};
  double pos_x = 0.0;
  double pos_y = 0.0;
  double pos_z = 0.0;
  double vel_x = 0.0;
  double vel_y = 0.0;
  double vel_z = 0.0;
  int32_t weapon_slot = 0;
  int32_t ammo_in_mag = 0;
  double dash_cooldown = 0.0;
  double health = 0.0;
  int32_t kills = 0;
  int32_t deaths = 0;
};

struct StateSnapshot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateSnapshotT NativeTableType;
  typedef StateSnapshotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_TICK = 4,
    VT_LAST_PROCESSED_INPUT_SEQ = 6,
    VT_CLIENT_ID = 8,
    VT_POS_X = 10,
    VT_POS_Y = 12,
    VT_POS_Z = 14,
    VT_VEL_X = 16,
    VT_VEL_Y = 18,
    VT_VEL_Z = 20,
    VT_WEAPON_SLOT = 22,
    VT_AMMO_IN_MAG = 24,
    VT_DASH_COOLDOWN = 26,
    VT_HEALTH = 28,
    VT_KILLS = 30,
    VT_DEATHS = 32
  };
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  int32_t last_processed_input_seq() const {
    return GetField<int32_t>(VT_LAST_PROCESSED_INPUT_SEQ, 0);
  }
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  double pos_x() const {
    return GetField<double>(VT_POS_X, 0.0);
  }
  double pos_y() const {
    return GetField<double>(VT_POS_Y, 0.0);
  }
  double pos_z() const {
    return GetField<double>(VT_POS_Z, 0.0);
  }
  double vel_x() const {
    return GetField<double>(VT_VEL_X, 0.0);
  }
  double vel_y() const {
    return GetField<double>(VT_VEL_Y, 0.0);
  }
  double vel_z() const {
    return GetField<double>(VT_VEL_Z, 0.0);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t ammo_in_mag() const {
    return GetField<int32_t>(VT_AMMO_IN_MAG, 0);
  }
  double dash_cooldown() const {
    return GetField<double>(VT_DASH_COOLDOWN, 0.0);
  }
  double health() const {
    return GetField<double>(VT_HEALTH, 0.0);
  }
  int32_t kills() const {
    return GetField<int32_t>(VT_KILLS, 0);
  }
  int32_t deaths() const {
    return GetField<int32_t>(VT_DEATHS, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           VerifyField<int32_t>(verifier, VT_LAST_PROCESSED_INPUT_SEQ, 4) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyField<double>(verifier, VT_POS_X, 8) &&
           VerifyField<double>(verifier, VT_POS_Y, 8) &&
           VerifyField<double>(verifier, VT_POS_Z, 8) &&
           VerifyField<double>(verifier, VT_VEL_X, 8) &&
           VerifyField<double>(verifier, VT_VEL_Y, 8) &&
           VerifyField<double>(verifier, VT_VEL_Z, 8) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<int32_t>(verifier, VT_AMMO_IN_MAG, 4) &&
           VerifyField<double>(verifier, VT_DASH_COOLDOWN, 8) &&
           VerifyField<double>(verifier, VT_HEALTH, 8) &&
           VerifyField<int32_t>(verifier, VT_KILLS, 4) &&
           VerifyField<int32_t>(verifier, VT_DEATHS, 4) &&
           verifier.EndTable();
  }
  StateSnapshotT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateSnapshotT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StateSnapshot> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateSnapshotBuilder {
  typedef StateSnapshot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_SERVER_TICK, server_tick, 0);
  }
  void add_last_processed_input_seq(int32_t last_processed_input_seq) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_LAST_PROCESSED_INPUT_SEQ, last_processed_input_seq, 0);
  }
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(StateSnapshot::VT_CLIENT_ID, client_id);
  }
  void add_pos_x(double pos_x) {
    fbb_.AddElement<double>(StateSnapshot::VT_POS_X, pos_x, 0.0);
  }
  void add_pos_y(double pos_y) {
    fbb_.AddElement<double>(StateSnapshot::VT_POS_Y, pos_y, 0.0);
  }
  void add_pos_z(double pos_z) {
    fbb_.AddElement<double>(StateSnapshot::VT_POS_Z, pos_z, 0.0);
  }
  void add_vel_x(double vel_x) {
    fbb_.AddElement<double>(StateSnapshot::VT_VEL_X, vel_x, 0.0);
  }
  void add_vel_y(double vel_y) {
    fbb_.AddElement<double>(StateSnapshot::VT_VEL_Y, vel_y, 0.0);
  }
  void add_vel_z(double vel_z) {
    fbb_.AddElement<double>(StateSnapshot::VT_VEL_Z, vel_z, 0.0);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_ammo_in_mag(int32_t ammo_in_mag) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_AMMO_IN_MAG, ammo_in_mag, 0);
  }
  void add_dash_cooldown(double dash_cooldown) {
    fbb_.AddElement<double>(StateSnapshot::VT_DASH_COOLDOWN, dash_cooldown, 0.0);
  }
  void add_health(double health) {
    fbb_.AddElement<double>(StateSnapshot::VT_HEALTH, health, 0.0);
  }
  void add_kills(int32_t kills) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_KILLS, kills, 0);
  }
  void add_deaths(int32_t deaths) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_DEATHS, deaths, 0);
  }
  explicit StateSnapshotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateSnapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateSnapshot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateSnapshot> CreateStateSnapshot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    int32_t last_processed_input_seq = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    int32_t weapon_slot = 0,
    int32_t ammo_in_mag = 0,
    double dash_cooldown = 0.0,
    double health = 0.0,
    int32_t kills = 0,
    int32_t deaths = 0) {
  StateSnapshotBuilder builder_(_fbb);
  builder_.add_health(health);
  builder_.add_dash_cooldown(dash_cooldown);
  builder_.add_vel_z(vel_z);
  builder_.add_vel_y(vel_y);
  builder_.add_vel_x(vel_x);
  builder_.add_pos_z(pos_z);
  builder_.add_pos_y(pos_y);
  builder_.add_pos_x(pos_x);
  builder_.add_deaths(deaths);
  builder_.add_kills(kills);
  builder_.add_ammo_in_mag(ammo_in_mag);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_client_id(client_id);
  builder_.add_last_processed_input_seq(last_processed_input_seq);
  builder_.add_server_tick(server_tick);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StateSnapshot> CreateStateSnapshotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    int32_t last_processed_input_seq = 0,
    const char *client_id = nullptr,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    int32_t weapon_slot = 0,
    int32_t ammo_in_mag = 0,
    double dash_cooldown = 0.0,
    double health = 0.0,
    int32_t kills = 0,
    int32_t deaths = 0) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  return afps::protocol::CreateStateSnapshot(
      _fbb,
      server_tick,
      last_processed_input_seq,
      client_id__,
      pos_x,
      pos_y,
      pos_z,
      vel_x,
      vel_y,
      vel_z,
      weapon_slot,
      ammo_in_mag,
      dash_cooldown,
      health,
      kills,
      deaths);
}

::flatbuffers::Offset<StateSnapshot> CreateStateSnapshot(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateSnapshotDeltaT : public ::flatbuffers::NativeTable {
  typedef StateSnapshotDelta TableType;
  int32_t server_tick = 0;
  int32_t base_tick = 0;
  int32_t last_processed_input_seq = 0;
  int32_t mask = 0;
  std::string client_id{};
  double pos_x = 0.0;
  double pos_y = 0.0;
  double pos_z = 0.0;
  double vel_x = 0.0;
  double vel_y = 0.0;
  double vel_z = 0.0;
  int32_t weapon_slot = 0;
  int32_t ammo_in_mag = 0;
  double dash_cooldown = 0.0;
  double health = 0.0;
  int32_t kills = 0;
  int32_t deaths = 0;
};

struct StateSnapshotDelta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateSnapshotDeltaT NativeTableType;
  typedef StateSnapshotDeltaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_TICK = 4,
    VT_BASE_TICK = 6,
    VT_LAST_PROCESSED_INPUT_SEQ = 8,
    VT_MASK = 10,
    VT_CLIENT_ID = 12,
    VT_POS_X = 14,
    VT_POS_Y = 16,
    VT_POS_Z = 18,
    VT_VEL_X = 20,
    VT_VEL_Y = 22,
    VT_VEL_Z = 24,
    VT_WEAPON_SLOT = 26,
    VT_AMMO_IN_MAG = 28,
    VT_DASH_COOLDOWN = 30,
    VT_HEALTH = 32,
    VT_KILLS = 34,
    VT_DEATHS = 36
  };
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  int32_t base_tick() const {
    return GetField<int32_t>(VT_BASE_TICK, 0);
  }
  int32_t last_processed_input_seq() const {
    return GetField<int32_t>(VT_LAST_PROCESSED_INPUT_SEQ, 0);
  }
  int32_t mask() const {
    return GetField<int32_t>(VT_MASK, 0);
  }
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  double pos_x() const {
    return GetField<double>(VT_POS_X, 0.0);
  }
  double pos_y() const {
    return GetField<double>(VT_POS_Y, 0.0);
  }
  double pos_z() const {
    return GetField<double>(VT_POS_Z, 0.0);
  }
  double vel_x() const {
    return GetField<double>(VT_VEL_X, 0.0);
  }
  double vel_y() const {
    return GetField<double>(VT_VEL_Y, 0.0);
  }
  double vel_z() const {
    return GetField<double>(VT_VEL_Z, 0.0);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t ammo_in_mag() const {
    return GetField<int32_t>(VT_AMMO_IN_MAG, 0);
  }
  double dash_cooldown() const {
    return GetField<double>(VT_DASH_COOLDOWN, 0.0);
  }
  double health() const {
    return GetField<double>(VT_HEALTH, 0.0);
  }
  int32_t kills() const {
    return GetField<int32_t>(VT_KILLS, 0);
  }
  int32_t deaths() const {
    return GetField<int32_t>(VT_DEATHS, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           VerifyField<int32_t>(verifier, VT_BASE_TICK, 4) &&
           VerifyField<int32_t>(verifier, VT_LAST_PROCESSED_INPUT_SEQ, 4) &&
           VerifyField<int32_t>(verifier, VT_MASK, 4) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyField<double>(verifier, VT_POS_X, 8) &&
           VerifyField<double>(verifier, VT_POS_Y, 8) &&
           VerifyField<double>(verifier, VT_POS_Z, 8) &&
           VerifyField<double>(verifier, VT_VEL_X, 8) &&
           VerifyField<double>(verifier, VT_VEL_Y, 8) &&
           VerifyField<double>(verifier, VT_VEL_Z, 8) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<int32_t>(verifier, VT_AMMO_IN_MAG, 4) &&
           VerifyField<double>(verifier, VT_DASH_COOLDOWN, 8) &&
           VerifyField<double>(verifier, VT_HEALTH, 8) &&
           VerifyField<int32_t>(verifier, VT_KILLS, 4) &&
           VerifyField<int32_t>(verifier, VT_DEATHS, 4) &&
           verifier.EndTable();
  }
  StateSnapshotDeltaT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateSnapshotDeltaT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StateSnapshotDelta> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotDeltaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateSnapshotDeltaBuilder {
  typedef StateSnapshotDelta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_SERVER_TICK, server_tick, 0);
  }
  void add_base_tick(int32_t base_tick) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_BASE_TICK, base_tick, 0);
  }
  void add_last_processed_input_seq(int32_t last_processed_input_seq) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_LAST_PROCESSED_INPUT_SEQ, last_processed_input_seq, 0);
  }
  void add_mask(int32_t mask) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_MASK, mask, 0);
  }
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(StateSnapshotDelta::VT_CLIENT_ID, client_id);
  }
  void add_pos_x(double pos_x) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_POS_X, pos_x, 0.0);
  }
  void add_pos_y(double pos_y) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_POS_Y, pos_y, 0.0);
  }
  void add_pos_z(double pos_z) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_POS_Z, pos_z, 0.0);
  }
  void add_vel_x(double vel_x) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_VEL_X, vel_x, 0.0);
  }
  void add_vel_y(double vel_y) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_VEL_Y, vel_y, 0.0);
  }
  void add_vel_z(double vel_z) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_VEL_Z, vel_z, 0.0);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_ammo_in_mag(int32_t ammo_in_mag) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_AMMO_IN_MAG, ammo_in_mag, 0);
  }
  void add_dash_cooldown(double dash_cooldown) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_DASH_COOLDOWN, dash_cooldown, 0.0);
  }
  void add_health(double health) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_HEALTH, health, 0.0);
  }
  void add_kills(int32_t kills) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_KILLS, kills, 0);
  }
  void add_deaths(int32_t deaths) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_DEATHS, deaths, 0);
  }
  explicit StateSnapshotDeltaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateSnapshotDelta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateSnapshotDelta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateSnapshotDelta> CreateStateSnapshotDelta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    int32_t base_tick = 0,
    int32_t last_processed_input_seq = 0,
    int32_t mask = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    int32_t weapon_slot = 0,
    int32_t ammo_in_mag = 0,
    double dash_cooldown = 0.0,
    double health = 0.0,
    int32_t kills = 0,
    int32_t deaths = 0) {
  StateSnapshotDeltaBuilder builder_(_fbb);
  builder_.add_health(health);
  builder_.add_dash_cooldown(dash_cooldown);
  builder_.add_vel_z(vel_z);
  builder_.add_vel_y(vel_y);
  builder_.add_vel_x(vel_x);
  builder_.add_pos_z(pos_z);
  builder_.add_pos_y(pos_y);
  builder_.add_pos_x(pos_x);
  builder_.add_deaths(deaths);
  builder_.add_kills(kills);
  builder_.add_ammo_in_mag(ammo_in_mag);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_client_id(client_id);
  builder_.add_mask(mask);
  builder_.add_last_processed_input_seq(last_processed_input_seq);
  builder_.add_base_tick(base_tick);
  builder_.add_server_tick(server_tick);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StateSnapshotDelta> CreateStateSnapshotDeltaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    int32_t base_tick = 0,
    int32_t last_processed_input_seq = 0,
    int32_t mask = 0,
    const char *client_id = nullptr,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    int32_t weapon_slot = 0,
    int32_t ammo_in_mag = 0,
    double dash_cooldown = 0.0,
    double health = 0.0,
    int32_t kills = 0,
    int32_t deaths = 0) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  return afps::protocol::CreateStateSnapshotDelta(
      _fbb,
      server_tick,
      base_tick,
      last_processed_input_seq,
      mask,
      client_id__,
      pos_x,
      pos_y,
      pos_z,
      vel_x,
      vel_y,
      vel_z,
      weapon_slot,
      ammo_in_mag,
      dash_cooldown,
      health,
      kills,
      deaths);
}

::flatbuffers::Offset<StateSnapshotDelta> CreateStateSnapshotDelta(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotDeltaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerProfileT : public ::flatbuffers::NativeTable {
  typedef PlayerProfile TableType;
  std::string client_id{};
  std::string nickname{};
  std::string character_id{};
};

struct PlayerProfile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerProfileT NativeTableType;
  typedef PlayerProfileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ID = 4,
    VT_NICKNAME = 6,
    VT_CHARACTER_ID = 8
  };
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  const ::flatbuffers::String *character_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARACTER_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           VerifyOffset(verifier, VT_CHARACTER_ID) &&
           verifier.VerifyString(character_id()) &&
           verifier.EndTable();
  }
  PlayerProfileT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerProfileT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlayerProfile> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerProfileT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerProfileBuilder {
  typedef PlayerProfile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(PlayerProfile::VT_CLIENT_ID, client_id);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(PlayerProfile::VT_NICKNAME, nickname);
  }
  void add_character_id(::flatbuffers::Offset<::flatbuffers::String> character_id) {
    fbb_.AddOffset(PlayerProfile::VT_CHARACTER_ID, character_id);
  }
  explicit PlayerProfileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerProfile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerProfile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerProfile> CreatePlayerProfile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> character_id = 0) {
  PlayerProfileBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  builder_.add_nickname(nickname);
  builder_.add_client_id(client_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerProfile> CreatePlayerProfileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *client_id = nullptr,
    const char *nickname = nullptr,
    const char *character_id = nullptr) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  auto character_id__ = character_id ? _fbb.CreateString(character_id) : 0;
  return afps::protocol::CreatePlayerProfile(
      _fbb,
      client_id__,
      nickname__,
      character_id__);
}

::flatbuffers::Offset<PlayerProfile> CreatePlayerProfile(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerProfileT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GameEventT : public ::flatbuffers::NativeTable {
  typedef GameEvent TableType;
  afps::protocol::GameEventType event_type = afps::protocol::GameEventType::HitConfirmed;
  std::string target_id{};
  std::string owner_id{};
  int32_t projectile_id = 0;
  double damage = 0.0;
  bool killed = false;
  double pos_x = 0.0;
  double pos_y = 0.0;
  double pos_z = 0.0;
  double vel_x = 0.0;
  double vel_y = 0.0;
  double vel_z = 0.0;
  double ttl = 0.0;
};

struct GameEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameEventT NativeTableType;
  typedef GameEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_TARGET_ID = 6,
    VT_OWNER_ID = 8,
    VT_PROJECTILE_ID = 10,
    VT_DAMAGE = 12,
    VT_KILLED = 14,
    VT_POS_X = 16,
    VT_POS_Y = 18,
    VT_POS_Z = 20,
    VT_VEL_X = 22,
    VT_VEL_Y = 24,
    VT_VEL_Z = 26,
    VT_TTL = 28
  };
  afps::protocol::GameEventType event_type() const {
    return static_cast<afps::protocol::GameEventType>(GetField<int8_t>(VT_EVENT_TYPE, 0));
  }
  const ::flatbuffers::String *target_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_ID);
  }
  const ::flatbuffers::String *owner_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OWNER_ID);
  }
  int32_t projectile_id() const {
    return GetField<int32_t>(VT_PROJECTILE_ID, 0);
  }
  double damage() const {
    return GetField<double>(VT_DAMAGE, 0.0);
  }
  bool killed() const {
    return GetField<uint8_t>(VT_KILLED, 0) != 0;
  }
  double pos_x() const {
    return GetField<double>(VT_POS_X, 0.0);
  }
  double pos_y() const {
    return GetField<double>(VT_POS_Y, 0.0);
  }
  double pos_z() const {
    return GetField<double>(VT_POS_Z, 0.0);
  }
  double vel_x() const {
    return GetField<double>(VT_VEL_X, 0.0);
  }
  double vel_y() const {
    return GetField<double>(VT_VEL_Y, 0.0);
  }
  double vel_z() const {
    return GetField<double>(VT_VEL_Z, 0.0);
  }
  double ttl() const {
    return GetField<double>(VT_TTL, 0.0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_TARGET_ID) &&
           verifier.VerifyString(target_id()) &&
           VerifyOffset(verifier, VT_OWNER_ID) &&
           verifier.VerifyString(owner_id()) &&
           VerifyField<int32_t>(verifier, VT_PROJECTILE_ID, 4) &&
           VerifyField<double>(verifier, VT_DAMAGE, 8) &&
           VerifyField<uint8_t>(verifier, VT_KILLED, 1) &&
           VerifyField<double>(verifier, VT_POS_X, 8) &&
           VerifyField<double>(verifier, VT_POS_Y, 8) &&
           VerifyField<double>(verifier, VT_POS_Z, 8) &&
           VerifyField<double>(verifier, VT_VEL_X, 8) &&
           VerifyField<double>(verifier, VT_VEL_Y, 8) &&
           VerifyField<double>(verifier, VT_VEL_Z, 8) &&
           VerifyField<double>(verifier, VT_TTL, 8) &&
           verifier.EndTable();
  }
  GameEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GameEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GameEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GameEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GameEventBuilder {
  typedef GameEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(afps::protocol::GameEventType event_type) {
    fbb_.AddElement<int8_t>(GameEvent::VT_EVENT_TYPE, static_cast<int8_t>(event_type), 0);
  }
  void add_target_id(::flatbuffers::Offset<::flatbuffers::String> target_id) {
    fbb_.AddOffset(GameEvent::VT_TARGET_ID, target_id);
  }
  void add_owner_id(::flatbuffers::Offset<::flatbuffers::String> owner_id) {
    fbb_.AddOffset(GameEvent::VT_OWNER_ID, owner_id);
  }
  void add_projectile_id(int32_t projectile_id) {
    fbb_.AddElement<int32_t>(GameEvent::VT_PROJECTILE_ID, projectile_id, 0);
  }
  void add_damage(double damage) {
    fbb_.AddElement<double>(GameEvent::VT_DAMAGE, damage, 0.0);
  }
  void add_killed(bool killed) {
    fbb_.AddElement<uint8_t>(GameEvent::VT_KILLED, static_cast<uint8_t>(killed), 0);
  }
  void add_pos_x(double pos_x) {
    fbb_.AddElement<double>(GameEvent::VT_POS_X, pos_x, 0.0);
  }
  void add_pos_y(double pos_y) {
    fbb_.AddElement<double>(GameEvent::VT_POS_Y, pos_y, 0.0);
  }
  void add_pos_z(double pos_z) {
    fbb_.AddElement<double>(GameEvent::VT_POS_Z, pos_z, 0.0);
  }
  void add_vel_x(double vel_x) {
    fbb_.AddElement<double>(GameEvent::VT_VEL_X, vel_x, 0.0);
  }
  void add_vel_y(double vel_y) {
    fbb_.AddElement<double>(GameEvent::VT_VEL_Y, vel_y, 0.0);
  }
  void add_vel_z(double vel_z) {
    fbb_.AddElement<double>(GameEvent::VT_VEL_Z, vel_z, 0.0);
  }
  void add_ttl(double ttl) {
    fbb_.AddElement<double>(GameEvent::VT_TTL, ttl, 0.0);
  }
  explicit GameEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameEvent> CreateGameEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    afps::protocol::GameEventType event_type = afps::protocol::GameEventType::HitConfirmed,
    ::flatbuffers::Offset<::flatbuffers::String> target_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> owner_id = 0,
    int32_t projectile_id = 0,
    double damage = 0.0,
    bool killed = false,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    double ttl = 0.0) {
  GameEventBuilder builder_(_fbb);
  builder_.add_ttl(ttl);
  builder_.add_vel_z(vel_z);
  builder_.add_vel_y(vel_y);
  builder_.add_vel_x(vel_x);
  builder_.add_pos_z(pos_z);
  builder_.add_pos_y(pos_y);
  builder_.add_pos_x(pos_x);
  builder_.add_damage(damage);
  builder_.add_projectile_id(projectile_id);
  builder_.add_owner_id(owner_id);
  builder_.add_target_id(target_id);
  builder_.add_killed(killed);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GameEvent> CreateGameEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    afps::protocol::GameEventType event_type = afps::protocol::GameEventType::HitConfirmed,
    const char *target_id = nullptr,
    const char *owner_id = nullptr,
    int32_t projectile_id = 0,
    double damage = 0.0,
    bool killed = false,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    double ttl = 0.0) {
  auto target_id__ = target_id ? _fbb.CreateString(target_id) : 0;
  auto owner_id__ = owner_id ? _fbb.CreateString(owner_id) : 0;
  return afps::protocol::CreateGameEvent(
      _fbb,
      event_type,
      target_id__,
      owner_id__,
      projectile_id,
      damage,
      killed,
      pos_x,
      pos_y,
      pos_z,
      vel_x,
      vel_y,
      vel_z,
      ttl);
}

::flatbuffers::Offset<GameEvent> CreateGameEvent(::flatbuffers::FlatBufferBuilder &_fbb, const GameEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PingT : public ::flatbuffers::NativeTable {
  typedef Ping TableType;
  double client_time_ms = 0.0;
};

struct Ping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PingT NativeTableType;
  typedef PingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_TIME_MS = 4
  };
  double client_time_ms() const {
    return GetField<double>(VT_CLIENT_TIME_MS, 0.0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_CLIENT_TIME_MS, 8) &&
           verifier.EndTable();
  }
  PingT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PingT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Ping> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PingBuilder {
  typedef Ping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_time_ms(double client_time_ms) {
    fbb_.AddElement<double>(Ping::VT_CLIENT_TIME_MS, client_time_ms, 0.0);
  }
  explicit PingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ping> CreatePing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double client_time_ms = 0.0) {
  PingBuilder builder_(_fbb);
  builder_.add_client_time_ms(client_time_ms);
  return builder_.Finish();
}

::flatbuffers::Offset<Ping> CreatePing(::flatbuffers::FlatBufferBuilder &_fbb, const PingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PongT : public ::flatbuffers::NativeTable {
  typedef Pong TableType;
  double client_time_ms = 0.0;
};

struct Pong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PongT NativeTableType;
  typedef PongBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_TIME_MS = 4
  };
  double client_time_ms() const {
    return GetField<double>(VT_CLIENT_TIME_MS, 0.0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_CLIENT_TIME_MS, 8) &&
           verifier.EndTable();
  }
  PongT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PongT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pong> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PongT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PongBuilder {
  typedef Pong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_time_ms(double client_time_ms) {
    fbb_.AddElement<double>(Pong::VT_CLIENT_TIME_MS, client_time_ms, 0.0);
  }
  explicit PongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pong> CreatePong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double client_time_ms = 0.0) {
  PongBuilder builder_(_fbb);
  builder_.add_client_time_ms(client_time_ms);
  return builder_.Finish();
}

::flatbuffers::Offset<Pong> CreatePong(::flatbuffers::FlatBufferBuilder &_fbb, const PongT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public ::flatbuffers::NativeTable {
  typedef Error TableType;
  std::string code{};
  std::string message{};
};

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorT NativeTableType;
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6
  };
  const ::flatbuffers::String *code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CODE);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Error> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(::flatbuffers::Offset<::flatbuffers::String> code) {
    fbb_.AddOffset(Error::VT_CODE, code);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const char *message = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return afps::protocol::CreateError(
      _fbb,
      code__,
      message__);
}

::flatbuffers::Offset<Error> CreateError(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DisconnectT : public ::flatbuffers::NativeTable {
  typedef Disconnect TableType;
  std::string code{};
  std::string message{};
};

struct Disconnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DisconnectT NativeTableType;
  typedef DisconnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6
  };
  const ::flatbuffers::String *code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CODE);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  DisconnectT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DisconnectT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Disconnect> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DisconnectT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DisconnectBuilder {
  typedef Disconnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(::flatbuffers::Offset<::flatbuffers::String> code) {
    fbb_.AddOffset(Disconnect::VT_CODE, code);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Disconnect::VT_MESSAGE, message);
  }
  explicit DisconnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Disconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Disconnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Disconnect> CreateDisconnect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  DisconnectBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Disconnect> CreateDisconnectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const char *message = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return afps::protocol::CreateDisconnect(
      _fbb,
      code__,
      message__);
}

::flatbuffers::Offset<Disconnect> CreateDisconnect(::flatbuffers::FlatBufferBuilder &_fbb, const DisconnectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ClientHelloT *ClientHello::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ClientHelloT>(new ClientHelloT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ClientHello::UnPackTo(ClientHelloT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = protocol_version(); _o->protocol_version = _e; }
  { auto _e = session_token(); if (_e) _o->session_token = _e->str(); }
  { auto _e = connection_id(); if (_e) _o->connection_id = _e->str(); }
  { auto _e = build(); if (_e) _o->build = _e->str(); }
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
  { auto _e = character_id(); if (_e) _o->character_id = _e->str(); }
}

inline ::flatbuffers::Offset<ClientHello> CreateClientHello(::flatbuffers::FlatBufferBuilder &_fbb, const ClientHelloT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ClientHello::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ClientHello> ClientHello::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ClientHelloT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ClientHelloT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _protocol_version = _o->protocol_version;
  auto _session_token = _o->session_token.empty() ? 0 : _fbb.CreateString(_o->session_token);
  auto _connection_id = _o->connection_id.empty() ? 0 : _fbb.CreateString(_o->connection_id);
  auto _build = _o->build.empty() ? 0 : _fbb.CreateString(_o->build);
  auto _nickname = _o->nickname.empty() ? 0 : _fbb.CreateString(_o->nickname);
  auto _character_id = _o->character_id.empty() ? 0 : _fbb.CreateString(_o->character_id);
  return afps::protocol::CreateClientHello(
      _fbb,
      _protocol_version,
      _session_token,
      _connection_id,
      _build,
      _nickname,
      _character_id);
}

inline ServerHelloT *ServerHello::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ServerHelloT>(new ServerHelloT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ServerHello::UnPackTo(ServerHelloT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = protocol_version(); _o->protocol_version = _e; }
  { auto _e = connection_id(); if (_e) _o->connection_id = _e->str(); }
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = server_tick_rate(); _o->server_tick_rate = _e; }
  { auto _e = snapshot_rate(); _o->snapshot_rate = _e; }
  { auto _e = snapshot_keyframe_interval(); _o->snapshot_keyframe_interval = _e; }
  { auto _e = motd(); if (_e) _o->motd = _e->str(); }
  { auto _e = connection_nonce(); if (_e) _o->connection_nonce = _e->str(); }
}

inline ::flatbuffers::Offset<ServerHello> CreateServerHello(::flatbuffers::FlatBufferBuilder &_fbb, const ServerHelloT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ServerHello::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ServerHello> ServerHello::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ServerHelloT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ServerHelloT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _protocol_version = _o->protocol_version;
  auto _connection_id = _o->connection_id.empty() ? 0 : _fbb.CreateString(_o->connection_id);
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _server_tick_rate = _o->server_tick_rate;
  auto _snapshot_rate = _o->snapshot_rate;
  auto _snapshot_keyframe_interval = _o->snapshot_keyframe_interval;
  auto _motd = _o->motd.empty() ? 0 : _fbb.CreateString(_o->motd);
  auto _connection_nonce = _o->connection_nonce.empty() ? 0 : _fbb.CreateString(_o->connection_nonce);
  return afps::protocol::CreateServerHello(
      _fbb,
      _protocol_version,
      _connection_id,
      _client_id,
      _server_tick_rate,
      _snapshot_rate,
      _snapshot_keyframe_interval,
      _motd,
      _connection_nonce);
}

inline JoinRequestT *JoinRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JoinRequestT>(new JoinRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JoinRequest::UnPackTo(JoinRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
  { auto _e = character_id(); if (_e) _o->character_id = _e->str(); }
}

inline ::flatbuffers::Offset<JoinRequest> CreateJoinRequest(::flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return JoinRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<JoinRequest> JoinRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JoinRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nickname = _o->nickname.empty() ? 0 : _fbb.CreateString(_o->nickname);
  auto _character_id = _o->character_id.empty() ? 0 : _fbb.CreateString(_o->character_id);
  return afps::protocol::CreateJoinRequest(
      _fbb,
      _nickname,
      _character_id);
}

inline JoinAcceptT *JoinAccept::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JoinAcceptT>(new JoinAcceptT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JoinAccept::UnPackTo(JoinAcceptT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
}

inline ::flatbuffers::Offset<JoinAccept> CreateJoinAccept(::flatbuffers::FlatBufferBuilder &_fbb, const JoinAcceptT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return JoinAccept::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<JoinAccept> JoinAccept::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoinAcceptT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JoinAcceptT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  return afps::protocol::CreateJoinAccept(
      _fbb,
      _client_id);
}

inline InputCmdT *InputCmd::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputCmdT>(new InputCmdT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InputCmd::UnPackTo(InputCmdT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = input_seq(); _o->input_seq = _e; }
  { auto _e = move_x(); _o->move_x = _e; }
  { auto _e = move_y(); _o->move_y = _e; }
  { auto _e = look_delta_x(); _o->look_delta_x = _e; }
  { auto _e = look_delta_y(); _o->look_delta_y = _e; }
  { auto _e = view_yaw(); _o->view_yaw = _e; }
  { auto _e = view_pitch(); _o->view_pitch = _e; }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = jump(); _o->jump = _e; }
  { auto _e = fire(); _o->fire = _e; }
  { auto _e = sprint(); _o->sprint = _e; }
  { auto _e = dash(); _o->dash = _e; }
  { auto _e = grapple(); _o->grapple = _e; }
  { auto _e = shield(); _o->shield = _e; }
  { auto _e = shockwave(); _o->shockwave = _e; }
}

inline ::flatbuffers::Offset<InputCmd> CreateInputCmd(::flatbuffers::FlatBufferBuilder &_fbb, const InputCmdT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return InputCmd::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<InputCmd> InputCmd::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InputCmdT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InputCmdT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _input_seq = _o->input_seq;
  auto _move_x = _o->move_x;
  auto _move_y = _o->move_y;
  auto _look_delta_x = _o->look_delta_x;
  auto _look_delta_y = _o->look_delta_y;
  auto _view_yaw = _o->view_yaw;
  auto _view_pitch = _o->view_pitch;
  auto _weapon_slot = _o->weapon_slot;
  auto _jump = _o->jump;
  auto _fire = _o->fire;
  auto _sprint = _o->sprint;
  auto _dash = _o->dash;
  auto _grapple = _o->grapple;
  auto _shield = _o->shield;
  auto _shockwave = _o->shockwave;
  return afps::protocol::CreateInputCmd(
      _fbb,
      _input_seq,
      _move_x,
      _move_y,
      _look_delta_x,
      _look_delta_y,
      _view_yaw,
      _view_pitch,
      _weapon_slot,
      _jump,
      _fire,
      _sprint,
      _dash,
      _grapple,
      _shield,
      _shockwave);
}

inline FireWeaponRequestT *FireWeaponRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FireWeaponRequestT>(new FireWeaponRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FireWeaponRequest::UnPackTo(FireWeaponRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_shot_seq(); _o->client_shot_seq = _e; }
  { auto _e = weapon_id(); if (_e) _o->weapon_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = origin_x(); _o->origin_x = _e; }
  { auto _e = origin_y(); _o->origin_y = _e; }
  { auto _e = origin_z(); _o->origin_z = _e; }
  { auto _e = dir_x(); _o->dir_x = _e; }
  { auto _e = dir_y(); _o->dir_y = _e; }
  { auto _e = dir_z(); _o->dir_z = _e; }
}

inline ::flatbuffers::Offset<FireWeaponRequest> CreateFireWeaponRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FireWeaponRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return FireWeaponRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FireWeaponRequest> FireWeaponRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FireWeaponRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FireWeaponRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_shot_seq = _o->client_shot_seq;
  auto _weapon_id = _o->weapon_id.empty() ? 0 : _fbb.CreateString(_o->weapon_id);
  auto _weapon_slot = _o->weapon_slot;
  auto _origin_x = _o->origin_x;
  auto _origin_y = _o->origin_y;
  auto _origin_z = _o->origin_z;
  auto _dir_x = _o->dir_x;
  auto _dir_y = _o->dir_y;
  auto _dir_z = _o->dir_z;
  return afps::protocol::CreateFireWeaponRequest(
      _fbb,
      _client_shot_seq,
      _weapon_id,
      _weapon_slot,
      _origin_x,
      _origin_y,
      _origin_z,
      _dir_x,
      _dir_y,
      _dir_z);
}

inline WeaponFiredEventT *WeaponFiredEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WeaponFiredEventT>(new WeaponFiredEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WeaponFiredEvent::UnPackTo(WeaponFiredEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = weapon_id(); if (_e) _o->weapon_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = server_tick(); _o->server_tick = _e; }
  { auto _e = shot_seq(); _o->shot_seq = _e; }
  { auto _e = muzzle_pos_x(); _o->muzzle_pos_x = _e; }
  { auto _e = muzzle_pos_y(); _o->muzzle_pos_y = _e; }
  { auto _e = muzzle_pos_z(); _o->muzzle_pos_z = _e; }
  { auto _e = dir_x(); _o->dir_x = _e; }
  { auto _e = dir_y(); _o->dir_y = _e; }
  { auto _e = dir_z(); _o->dir_z = _e; }
  { auto _e = dry_fire(); _o->dry_fire = _e; }
  { auto _e = casing_enabled(); _o->casing_enabled = _e; }
  { auto _e = casing_pos_x(); _o->casing_pos_x = _e; }
  { auto _e = casing_pos_y(); _o->casing_pos_y = _e; }
  { auto _e = casing_pos_z(); _o->casing_pos_z = _e; }
  { auto _e = casing_rot_x(); _o->casing_rot_x = _e; }
  { auto _e = casing_rot_y(); _o->casing_rot_y = _e; }
  { auto _e = casing_rot_z(); _o->casing_rot_z = _e; }
  { auto _e = casing_vel_x(); _o->casing_vel_x = _e; }
  { auto _e = casing_vel_y(); _o->casing_vel_y = _e; }
  { auto _e = casing_vel_z(); _o->casing_vel_z = _e; }
  { auto _e = casing_ang_x(); _o->casing_ang_x = _e; }
  { auto _e = casing_ang_y(); _o->casing_ang_y = _e; }
  { auto _e = casing_ang_z(); _o->casing_ang_z = _e; }
  { auto _e = casing_seed(); _o->casing_seed = _e; }
}

inline ::flatbuffers::Offset<WeaponFiredEvent> CreateWeaponFiredEvent(::flatbuffers::FlatBufferBuilder &_fbb, const WeaponFiredEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return WeaponFiredEvent::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WeaponFiredEvent> WeaponFiredEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WeaponFiredEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WeaponFiredEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _weapon_id = _o->weapon_id.empty() ? 0 : _fbb.CreateString(_o->weapon_id);
  auto _weapon_slot = _o->weapon_slot;
  auto _server_tick = _o->server_tick;
  auto _shot_seq = _o->shot_seq;
  auto _muzzle_pos_x = _o->muzzle_pos_x;
  auto _muzzle_pos_y = _o->muzzle_pos_y;
  auto _muzzle_pos_z = _o->muzzle_pos_z;
  auto _dir_x = _o->dir_x;
  auto _dir_y = _o->dir_y;
  auto _dir_z = _o->dir_z;
  auto _dry_fire = _o->dry_fire;
  auto _casing_enabled = _o->casing_enabled;
  auto _casing_pos_x = _o->casing_pos_x;
  auto _casing_pos_y = _o->casing_pos_y;
  auto _casing_pos_z = _o->casing_pos_z;
  auto _casing_rot_x = _o->casing_rot_x;
  auto _casing_rot_y = _o->casing_rot_y;
  auto _casing_rot_z = _o->casing_rot_z;
  auto _casing_vel_x = _o->casing_vel_x;
  auto _casing_vel_y = _o->casing_vel_y;
  auto _casing_vel_z = _o->casing_vel_z;
  auto _casing_ang_x = _o->casing_ang_x;
  auto _casing_ang_y = _o->casing_ang_y;
  auto _casing_ang_z = _o->casing_ang_z;
  auto _casing_seed = _o->casing_seed;
  return afps::protocol::CreateWeaponFiredEvent(
      _fbb,
      _shooter_id,
      _weapon_id,
      _weapon_slot,
      _server_tick,
      _shot_seq,
      _muzzle_pos_x,
      _muzzle_pos_y,
      _muzzle_pos_z,
      _dir_x,
      _dir_y,
      _dir_z,
      _dry_fire,
      _casing_enabled,
      _casing_pos_x,
      _casing_pos_y,
      _casing_pos_z,
      _casing_rot_x,
      _casing_rot_y,
      _casing_rot_z,
      _casing_vel_x,
      _casing_vel_y,
      _casing_vel_z,
      _casing_ang_x,
      _casing_ang_y,
      _casing_ang_z,
      _casing_seed);
}

inline WeaponReloadEventT *WeaponReloadEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WeaponReloadEventT>(new WeaponReloadEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WeaponReloadEvent::UnPackTo(WeaponReloadEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = weapon_id(); if (_e) _o->weapon_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = server_tick(); _o->server_tick = _e; }
  { auto _e = reload_seconds(); _o->reload_seconds = _e; }
}

inline ::flatbuffers::Offset<WeaponReloadEvent> CreateWeaponReloadEvent(::flatbuffers::FlatBufferBuilder &_fbb, const WeaponReloadEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return WeaponReloadEvent::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WeaponReloadEvent> WeaponReloadEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WeaponReloadEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WeaponReloadEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _weapon_id = _o->weapon_id.empty() ? 0 : _fbb.CreateString(_o->weapon_id);
  auto _weapon_slot = _o->weapon_slot;
  auto _server_tick = _o->server_tick;
  auto _reload_seconds = _o->reload_seconds;
  return afps::protocol::CreateWeaponReloadEvent(
      _fbb,
      _shooter_id,
      _weapon_id,
      _weapon_slot,
      _server_tick,
      _reload_seconds);
}

inline StateSnapshotT *StateSnapshot::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StateSnapshotT>(new StateSnapshotT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StateSnapshot::UnPackTo(StateSnapshotT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = server_tick(); _o->server_tick = _e; }
  { auto _e = last_processed_input_seq(); _o->last_processed_input_seq = _e; }
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = pos_x(); _o->pos_x = _e; }
  { auto _e = pos_y(); _o->pos_y = _e; }
  { auto _e = pos_z(); _o->pos_z = _e; }
  { auto _e = vel_x(); _o->vel_x = _e; }
  { auto _e = vel_y(); _o->vel_y = _e; }
  { auto _e = vel_z(); _o->vel_z = _e; }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = ammo_in_mag(); _o->ammo_in_mag = _e; }
  { auto _e = dash_cooldown(); _o->dash_cooldown = _e; }
  { auto _e = health(); _o->health = _e; }
  { auto _e = kills(); _o->kills = _e; }
  { auto _e = deaths(); _o->deaths = _e; }
}

inline ::flatbuffers::Offset<StateSnapshot> CreateStateSnapshot(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return StateSnapshot::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StateSnapshot> StateSnapshot::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StateSnapshotT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _server_tick = _o->server_tick;
  auto _last_processed_input_seq = _o->last_processed_input_seq;
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _pos_x = _o->pos_x;
  auto _pos_y = _o->pos_y;
  auto _pos_z = _o->pos_z;
  auto _vel_x = _o->vel_x;
  auto _vel_y = _o->vel_y;
  auto _vel_z = _o->vel_z;
  auto _weapon_slot = _o->weapon_slot;
  auto _ammo_in_mag = _o->ammo_in_mag;
  auto _dash_cooldown = _o->dash_cooldown;
  auto _health = _o->health;
  auto _kills = _o->kills;
  auto _deaths = _o->deaths;
  return afps::protocol::CreateStateSnapshot(
      _fbb,
      _server_tick,
      _last_processed_input_seq,
      _client_id,
      _pos_x,
      _pos_y,
      _pos_z,
      _vel_x,
      _vel_y,
      _vel_z,
      _weapon_slot,
      _ammo_in_mag,
      _dash_cooldown,
      _health,
      _kills,
      _deaths);
}

inline StateSnapshotDeltaT *StateSnapshotDelta::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StateSnapshotDeltaT>(new StateSnapshotDeltaT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StateSnapshotDelta::UnPackTo(StateSnapshotDeltaT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = server_tick(); _o->server_tick = _e; }
  { auto _e = base_tick(); _o->base_tick = _e; }
  { auto _e = last_processed_input_seq(); _o->last_processed_input_seq = _e; }
  { auto _e = mask(); _o->mask = _e; }
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = pos_x(); _o->pos_x = _e; }
  { auto _e = pos_y(); _o->pos_y = _e; }
  { auto _e = pos_z(); _o->pos_z = _e; }
  { auto _e = vel_x(); _o->vel_x = _e; }
  { auto _e = vel_y(); _o->vel_y = _e; }
  { auto _e = vel_z(); _o->vel_z = _e; }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = ammo_in_mag(); _o->ammo_in_mag = _e; }
  { auto _e = dash_cooldown(); _o->dash_cooldown = _e; }
  { auto _e = health(); _o->health = _e; }
  { auto _e = kills(); _o->kills = _e; }
  { auto _e = deaths(); _o->deaths = _e; }
}

inline ::flatbuffers::Offset<StateSnapshotDelta> CreateStateSnapshotDelta(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotDeltaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return StateSnapshotDelta::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StateSnapshotDelta> StateSnapshotDelta::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotDeltaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StateSnapshotDeltaT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _server_tick = _o->server_tick;
  auto _base_tick = _o->base_tick;
  auto _last_processed_input_seq = _o->last_processed_input_seq;
  auto _mask = _o->mask;
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _pos_x = _o->pos_x;
  auto _pos_y = _o->pos_y;
  auto _pos_z = _o->pos_z;
  auto _vel_x = _o->vel_x;
  auto _vel_y = _o->vel_y;
  auto _vel_z = _o->vel_z;
  auto _weapon_slot = _o->weapon_slot;
  auto _ammo_in_mag = _o->ammo_in_mag;
  auto _dash_cooldown = _o->dash_cooldown;
  auto _health = _o->health;
  auto _kills = _o->kills;
  auto _deaths = _o->deaths;
  return afps::protocol::CreateStateSnapshotDelta(
      _fbb,
      _server_tick,
      _base_tick,
      _last_processed_input_seq,
      _mask,
      _client_id,
      _pos_x,
      _pos_y,
      _pos_z,
      _vel_x,
      _vel_y,
      _vel_z,
      _weapon_slot,
      _ammo_in_mag,
      _dash_cooldown,
      _health,
      _kills,
      _deaths);
}

inline PlayerProfileT *PlayerProfile::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlayerProfileT>(new PlayerProfileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerProfile::UnPackTo(PlayerProfileT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
  { auto _e = character_id(); if (_e) _o->character_id = _e->str(); }
}

inline ::flatbuffers::Offset<PlayerProfile> CreatePlayerProfile(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerProfileT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return PlayerProfile::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlayerProfile> PlayerProfile::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerProfileT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlayerProfileT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _nickname = _o->nickname.empty() ? 0 : _fbb.CreateString(_o->nickname);
  auto _character_id = _o->character_id.empty() ? 0 : _fbb.CreateString(_o->character_id);
  return afps::protocol::CreatePlayerProfile(
      _fbb,
      _client_id,
      _nickname,
      _character_id);
}

inline GameEventT *GameEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GameEventT>(new GameEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GameEvent::UnPackTo(GameEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_type(); _o->event_type = _e; }
  { auto _e = target_id(); if (_e) _o->target_id = _e->str(); }
  { auto _e = owner_id(); if (_e) _o->owner_id = _e->str(); }
  { auto _e = projectile_id(); _o->projectile_id = _e; }
  { auto _e = damage(); _o->damage = _e; }
  { auto _e = killed(); _o->killed = _e; }
  { auto _e = pos_x(); _o->pos_x = _e; }
  { auto _e = pos_y(); _o->pos_y = _e; }
  { auto _e = pos_z(); _o->pos_z = _e; }
  { auto _e = vel_x(); _o->vel_x = _e; }
  { auto _e = vel_y(); _o->vel_y = _e; }
  { auto _e = vel_z(); _o->vel_z = _e; }
  { auto _e = ttl(); _o->ttl = _e; }
}

inline ::flatbuffers::Offset<GameEvent> CreateGameEvent(::flatbuffers::FlatBufferBuilder &_fbb, const GameEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return GameEvent::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GameEvent> GameEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GameEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GameEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_type = _o->event_type;
  auto _target_id = _o->target_id.empty() ? 0 : _fbb.CreateString(_o->target_id);
  auto _owner_id = _o->owner_id.empty() ? 0 : _fbb.CreateString(_o->owner_id);
  auto _projectile_id = _o->projectile_id;
  auto _damage = _o->damage;
  auto _killed = _o->killed;
  auto _pos_x = _o->pos_x;
  auto _pos_y = _o->pos_y;
  auto _pos_z = _o->pos_z;
  auto _vel_x = _o->vel_x;
  auto _vel_y = _o->vel_y;
  auto _vel_z = _o->vel_z;
  auto _ttl = _o->ttl;
  return afps::protocol::CreateGameEvent(
      _fbb,
      _event_type,
      _target_id,
      _owner_id,
      _projectile_id,
      _damage,
      _killed,
      _pos_x,
      _pos_y,
      _pos_z,
      _vel_x,
      _vel_y,
      _vel_z,
      _ttl);
}

inline PingT *Ping::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PingT>(new PingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Ping::UnPackTo(PingT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_time_ms(); _o->client_time_ms = _e; }
}

inline ::flatbuffers::Offset<Ping> CreatePing(::flatbuffers::FlatBufferBuilder &_fbb, const PingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Ping::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Ping> Ping::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PingT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_time_ms = _o->client_time_ms;
  return afps::protocol::CreatePing(
      _fbb,
      _client_time_ms);
}

inline PongT *Pong::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PongT>(new PongT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pong::UnPackTo(PongT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_time_ms(); _o->client_time_ms = _e; }
}

inline ::flatbuffers::Offset<Pong> CreatePong(::flatbuffers::FlatBufferBuilder &_fbb, const PongT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Pong::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pong> Pong::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PongT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PongT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_time_ms = _o->client_time_ms;
  return afps::protocol::CreatePong(
      _fbb,
      _client_time_ms);
}

inline ErrorT *Error::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ErrorT>(new ErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Error::UnPackTo(ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<Error> CreateError(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Error::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Error> Error::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return afps::protocol::CreateError(
      _fbb,
      _code,
      _message);
}

inline DisconnectT *Disconnect::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DisconnectT>(new DisconnectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Disconnect::UnPackTo(DisconnectT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<Disconnect> CreateDisconnect(::flatbuffers::FlatBufferBuilder &_fbb, const DisconnectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Disconnect::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Disconnect> Disconnect::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DisconnectT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DisconnectT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return afps::protocol::CreateDisconnect(
      _fbb,
      _code,
      _message);
}

}  // namespace protocol
}  // namespace afps

#endif  // FLATBUFFERS_GENERATED_AFPSPROTOCOL_AFPS_PROTOCOL_H_
