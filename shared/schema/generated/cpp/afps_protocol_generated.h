// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AFPSPROTOCOL_AFPS_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_AFPSPROTOCOL_AFPS_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace afps {
namespace protocol {

struct ShotFiredFx;
struct ShotFiredFxBuilder;
struct ShotFiredFxT;

struct ShotTraceFx;
struct ShotTraceFxBuilder;
struct ShotTraceFxT;

struct ReloadFx;
struct ReloadFxBuilder;
struct ReloadFxT;

struct NearMissFx;
struct NearMissFxBuilder;
struct NearMissFxT;

struct OverheatFx;
struct OverheatFxBuilder;
struct OverheatFxT;

struct VentFx;
struct VentFxBuilder;
struct VentFxT;

struct HitConfirmedFx;
struct HitConfirmedFxBuilder;
struct HitConfirmedFxT;

struct KillFeedFx;
struct KillFeedFxBuilder;
struct KillFeedFxT;

struct ProjectileSpawnFx;
struct ProjectileSpawnFxBuilder;
struct ProjectileSpawnFxT;

struct ProjectileImpactFx;
struct ProjectileImpactFxBuilder;
struct ProjectileImpactFxT;

struct ProjectileRemoveFx;
struct ProjectileRemoveFxBuilder;
struct ProjectileRemoveFxT;

struct PickupSpawnedFx;
struct PickupSpawnedFxBuilder;
struct PickupSpawnedFxT;

struct PickupTakenFx;
struct PickupTakenFxBuilder;
struct PickupTakenFxT;

struct ClientHello;
struct ClientHelloBuilder;
struct ClientHelloT;

struct ServerHello;
struct ServerHelloBuilder;
struct ServerHelloT;

struct JoinRequest;
struct JoinRequestBuilder;
struct JoinRequestT;

struct JoinAccept;
struct JoinAcceptBuilder;
struct JoinAcceptT;

struct InputCmd;
struct InputCmdBuilder;
struct InputCmdT;

struct FireWeaponRequest;
struct FireWeaponRequestBuilder;
struct FireWeaponRequestT;

struct SetLoadoutRequest;
struct SetLoadoutRequestBuilder;
struct SetLoadoutRequestT;

struct StateSnapshot;
struct StateSnapshotBuilder;
struct StateSnapshotT;

struct StateSnapshotDelta;
struct StateSnapshotDeltaBuilder;
struct StateSnapshotDeltaT;

struct PlayerProfile;
struct PlayerProfileBuilder;
struct PlayerProfileT;

struct GameEvent;
struct GameEventBuilder;
struct GameEventT;

struct Ping;
struct PingBuilder;
struct PingT;

struct Pong;
struct PongBuilder;
struct PongT;

struct Error;
struct ErrorBuilder;
struct ErrorT;

struct Disconnect;
struct DisconnectBuilder;
struct DisconnectT;

enum class SchemaVersion : uint16_t {
  V1 = 1,
  MIN = V1,
  MAX = V1
};

inline const SchemaVersion (&EnumValuesSchemaVersion())[1] {
  static const SchemaVersion values[] = {
    SchemaVersion::V1
  };
  return values;
}

inline const char * const *EnumNamesSchemaVersion() {
  static const char * const names[2] = {
    "V1",
    nullptr
  };
  return names;
}

inline const char *EnumNameSchemaVersion(SchemaVersion e) {
  if (::flatbuffers::IsOutRange(e, SchemaVersion::V1, SchemaVersion::V1)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(SchemaVersion::V1);
  return EnumNamesSchemaVersion()[index];
}

enum class MessageType : uint16_t {
  ClientHello = 1,
  ServerHello = 2,
  JoinRequest = 3,
  JoinAccept = 4,
  InputCmd = 5,
  StateSnapshot = 6,
  StateSnapshotDelta = 7,
  GameEvent = 8,
  Ping = 9,
  Pong = 10,
  PlayerProfile = 11,
  Error = 12,
  Disconnect = 13,
  FireWeaponRequest = 14,
  SetLoadoutRequest = 15,
  MIN = ClientHello,
  MAX = SetLoadoutRequest
};

inline const MessageType (&EnumValuesMessageType())[15] {
  static const MessageType values[] = {
    MessageType::ClientHello,
    MessageType::ServerHello,
    MessageType::JoinRequest,
    MessageType::JoinAccept,
    MessageType::InputCmd,
    MessageType::StateSnapshot,
    MessageType::StateSnapshotDelta,
    MessageType::GameEvent,
    MessageType::Ping,
    MessageType::Pong,
    MessageType::PlayerProfile,
    MessageType::Error,
    MessageType::Disconnect,
    MessageType::FireWeaponRequest,
    MessageType::SetLoadoutRequest
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[16] = {
    "ClientHello",
    "ServerHello",
    "JoinRequest",
    "JoinAccept",
    "InputCmd",
    "StateSnapshot",
    "StateSnapshotDelta",
    "GameEvent",
    "Ping",
    "Pong",
    "PlayerProfile",
    "Error",
    "Disconnect",
    "FireWeaponRequest",
    "SetLoadoutRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType::ClientHello, MessageType::SetLoadoutRequest)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(MessageType::ClientHello);
  return EnumNamesMessageType()[index];
}

enum class HitKind : uint8_t {
  None = 0,
  World = 1,
  Player = 2,
  MIN = None,
  MAX = Player
};

inline const HitKind (&EnumValuesHitKind())[3] {
  static const HitKind values[] = {
    HitKind::None,
    HitKind::World,
    HitKind::Player
  };
  return values;
}

inline const char * const *EnumNamesHitKind() {
  static const char * const names[4] = {
    "None",
    "World",
    "Player",
    nullptr
  };
  return names;
}

inline const char *EnumNameHitKind(HitKind e) {
  if (::flatbuffers::IsOutRange(e, HitKind::None, HitKind::Player)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHitKind()[index];
}

enum class SurfaceType : uint8_t {
  Stone = 0,
  Metal = 1,
  Dirt = 2,
  Energy = 3,
  MIN = Stone,
  MAX = Energy
};

inline const SurfaceType (&EnumValuesSurfaceType())[4] {
  static const SurfaceType values[] = {
    SurfaceType::Stone,
    SurfaceType::Metal,
    SurfaceType::Dirt,
    SurfaceType::Energy
  };
  return values;
}

inline const char * const *EnumNamesSurfaceType() {
  static const char * const names[5] = {
    "Stone",
    "Metal",
    "Dirt",
    "Energy",
    nullptr
  };
  return names;
}

inline const char *EnumNameSurfaceType(SurfaceType e) {
  if (::flatbuffers::IsOutRange(e, SurfaceType::Stone, SurfaceType::Energy)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSurfaceType()[index];
}

enum class PickupKind : uint8_t {
  None = 0,
  Health = 1,
  Weapon = 2,
  MIN = None,
  MAX = Weapon
};

inline const PickupKind (&EnumValuesPickupKind())[3] {
  static const PickupKind values[] = {
    PickupKind::None,
    PickupKind::Health,
    PickupKind::Weapon
  };
  return values;
}

inline const char * const *EnumNamesPickupKind() {
  static const char * const names[4] = {
    "None",
    "Health",
    "Weapon",
    nullptr
  };
  return names;
}

inline const char *EnumNamePickupKind(PickupKind e) {
  if (::flatbuffers::IsOutRange(e, PickupKind::None, PickupKind::Weapon)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPickupKind()[index];
}

enum class FxEvent : uint8_t {
  NONE = 0,
  ShotFiredFx = 1,
  ShotTraceFx = 2,
  ReloadFx = 3,
  NearMissFx = 4,
  OverheatFx = 5,
  VentFx = 6,
  HitConfirmedFx = 7,
  KillFeedFx = 8,
  ProjectileSpawnFx = 9,
  ProjectileImpactFx = 10,
  ProjectileRemoveFx = 11,
  PickupSpawnedFx = 12,
  PickupTakenFx = 13,
  MIN = NONE,
  MAX = PickupTakenFx
};

inline const FxEvent (&EnumValuesFxEvent())[14] {
  static const FxEvent values[] = {
    FxEvent::NONE,
    FxEvent::ShotFiredFx,
    FxEvent::ShotTraceFx,
    FxEvent::ReloadFx,
    FxEvent::NearMissFx,
    FxEvent::OverheatFx,
    FxEvent::VentFx,
    FxEvent::HitConfirmedFx,
    FxEvent::KillFeedFx,
    FxEvent::ProjectileSpawnFx,
    FxEvent::ProjectileImpactFx,
    FxEvent::ProjectileRemoveFx,
    FxEvent::PickupSpawnedFx,
    FxEvent::PickupTakenFx
  };
  return values;
}

inline const char * const *EnumNamesFxEvent() {
  static const char * const names[15] = {
    "NONE",
    "ShotFiredFx",
    "ShotTraceFx",
    "ReloadFx",
    "NearMissFx",
    "OverheatFx",
    "VentFx",
    "HitConfirmedFx",
    "KillFeedFx",
    "ProjectileSpawnFx",
    "ProjectileImpactFx",
    "ProjectileRemoveFx",
    "PickupSpawnedFx",
    "PickupTakenFx",
    nullptr
  };
  return names;
}

inline const char *EnumNameFxEvent(FxEvent e) {
  if (::flatbuffers::IsOutRange(e, FxEvent::NONE, FxEvent::PickupTakenFx)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFxEvent()[index];
}

template<typename T> struct FxEventTraits {
  static const FxEvent enum_value = FxEvent::NONE;
};

template<> struct FxEventTraits<afps::protocol::ShotFiredFx> {
  static const FxEvent enum_value = FxEvent::ShotFiredFx;
};

template<> struct FxEventTraits<afps::protocol::ShotTraceFx> {
  static const FxEvent enum_value = FxEvent::ShotTraceFx;
};

template<> struct FxEventTraits<afps::protocol::ReloadFx> {
  static const FxEvent enum_value = FxEvent::ReloadFx;
};

template<> struct FxEventTraits<afps::protocol::NearMissFx> {
  static const FxEvent enum_value = FxEvent::NearMissFx;
};

template<> struct FxEventTraits<afps::protocol::OverheatFx> {
  static const FxEvent enum_value = FxEvent::OverheatFx;
};

template<> struct FxEventTraits<afps::protocol::VentFx> {
  static const FxEvent enum_value = FxEvent::VentFx;
};

template<> struct FxEventTraits<afps::protocol::HitConfirmedFx> {
  static const FxEvent enum_value = FxEvent::HitConfirmedFx;
};

template<> struct FxEventTraits<afps::protocol::KillFeedFx> {
  static const FxEvent enum_value = FxEvent::KillFeedFx;
};

template<> struct FxEventTraits<afps::protocol::ProjectileSpawnFx> {
  static const FxEvent enum_value = FxEvent::ProjectileSpawnFx;
};

template<> struct FxEventTraits<afps::protocol::ProjectileImpactFx> {
  static const FxEvent enum_value = FxEvent::ProjectileImpactFx;
};

template<> struct FxEventTraits<afps::protocol::ProjectileRemoveFx> {
  static const FxEvent enum_value = FxEvent::ProjectileRemoveFx;
};

template<> struct FxEventTraits<afps::protocol::PickupSpawnedFx> {
  static const FxEvent enum_value = FxEvent::PickupSpawnedFx;
};

template<> struct FxEventTraits<afps::protocol::PickupTakenFx> {
  static const FxEvent enum_value = FxEvent::PickupTakenFx;
};

template<typename T> struct FxEventUnionTraits {
  static const FxEvent enum_value = FxEvent::NONE;
};

template<> struct FxEventUnionTraits<afps::protocol::ShotFiredFxT> {
  static const FxEvent enum_value = FxEvent::ShotFiredFx;
};

template<> struct FxEventUnionTraits<afps::protocol::ShotTraceFxT> {
  static const FxEvent enum_value = FxEvent::ShotTraceFx;
};

template<> struct FxEventUnionTraits<afps::protocol::ReloadFxT> {
  static const FxEvent enum_value = FxEvent::ReloadFx;
};

template<> struct FxEventUnionTraits<afps::protocol::NearMissFxT> {
  static const FxEvent enum_value = FxEvent::NearMissFx;
};

template<> struct FxEventUnionTraits<afps::protocol::OverheatFxT> {
  static const FxEvent enum_value = FxEvent::OverheatFx;
};

template<> struct FxEventUnionTraits<afps::protocol::VentFxT> {
  static const FxEvent enum_value = FxEvent::VentFx;
};

template<> struct FxEventUnionTraits<afps::protocol::HitConfirmedFxT> {
  static const FxEvent enum_value = FxEvent::HitConfirmedFx;
};

template<> struct FxEventUnionTraits<afps::protocol::KillFeedFxT> {
  static const FxEvent enum_value = FxEvent::KillFeedFx;
};

template<> struct FxEventUnionTraits<afps::protocol::ProjectileSpawnFxT> {
  static const FxEvent enum_value = FxEvent::ProjectileSpawnFx;
};

template<> struct FxEventUnionTraits<afps::protocol::ProjectileImpactFxT> {
  static const FxEvent enum_value = FxEvent::ProjectileImpactFx;
};

template<> struct FxEventUnionTraits<afps::protocol::ProjectileRemoveFxT> {
  static const FxEvent enum_value = FxEvent::ProjectileRemoveFx;
};

template<> struct FxEventUnionTraits<afps::protocol::PickupSpawnedFxT> {
  static const FxEvent enum_value = FxEvent::PickupSpawnedFx;
};

template<> struct FxEventUnionTraits<afps::protocol::PickupTakenFxT> {
  static const FxEvent enum_value = FxEvent::PickupTakenFx;
};

struct FxEventUnion {
  FxEvent type;
  void *value;

  FxEventUnion() : type(FxEvent::NONE), value(nullptr) {}
  FxEventUnion(FxEventUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(FxEvent::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  FxEventUnion(const FxEventUnion &);
  FxEventUnion &operator=(const FxEventUnion &u)
    { FxEventUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  FxEventUnion &operator=(FxEventUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~FxEventUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = FxEventUnionTraits<RT>::enum_value;
    if (type != FxEvent::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, FxEvent type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  afps::protocol::ShotFiredFxT *AsShotFiredFx() {
    return type == FxEvent::ShotFiredFx ?
      reinterpret_cast<afps::protocol::ShotFiredFxT *>(value) : nullptr;
  }
  const afps::protocol::ShotFiredFxT *AsShotFiredFx() const {
    return type == FxEvent::ShotFiredFx ?
      reinterpret_cast<const afps::protocol::ShotFiredFxT *>(value) : nullptr;
  }
  afps::protocol::ShotTraceFxT *AsShotTraceFx() {
    return type == FxEvent::ShotTraceFx ?
      reinterpret_cast<afps::protocol::ShotTraceFxT *>(value) : nullptr;
  }
  const afps::protocol::ShotTraceFxT *AsShotTraceFx() const {
    return type == FxEvent::ShotTraceFx ?
      reinterpret_cast<const afps::protocol::ShotTraceFxT *>(value) : nullptr;
  }
  afps::protocol::ReloadFxT *AsReloadFx() {
    return type == FxEvent::ReloadFx ?
      reinterpret_cast<afps::protocol::ReloadFxT *>(value) : nullptr;
  }
  const afps::protocol::ReloadFxT *AsReloadFx() const {
    return type == FxEvent::ReloadFx ?
      reinterpret_cast<const afps::protocol::ReloadFxT *>(value) : nullptr;
  }
  afps::protocol::NearMissFxT *AsNearMissFx() {
    return type == FxEvent::NearMissFx ?
      reinterpret_cast<afps::protocol::NearMissFxT *>(value) : nullptr;
  }
  const afps::protocol::NearMissFxT *AsNearMissFx() const {
    return type == FxEvent::NearMissFx ?
      reinterpret_cast<const afps::protocol::NearMissFxT *>(value) : nullptr;
  }
  afps::protocol::OverheatFxT *AsOverheatFx() {
    return type == FxEvent::OverheatFx ?
      reinterpret_cast<afps::protocol::OverheatFxT *>(value) : nullptr;
  }
  const afps::protocol::OverheatFxT *AsOverheatFx() const {
    return type == FxEvent::OverheatFx ?
      reinterpret_cast<const afps::protocol::OverheatFxT *>(value) : nullptr;
  }
  afps::protocol::VentFxT *AsVentFx() {
    return type == FxEvent::VentFx ?
      reinterpret_cast<afps::protocol::VentFxT *>(value) : nullptr;
  }
  const afps::protocol::VentFxT *AsVentFx() const {
    return type == FxEvent::VentFx ?
      reinterpret_cast<const afps::protocol::VentFxT *>(value) : nullptr;
  }
  afps::protocol::HitConfirmedFxT *AsHitConfirmedFx() {
    return type == FxEvent::HitConfirmedFx ?
      reinterpret_cast<afps::protocol::HitConfirmedFxT *>(value) : nullptr;
  }
  const afps::protocol::HitConfirmedFxT *AsHitConfirmedFx() const {
    return type == FxEvent::HitConfirmedFx ?
      reinterpret_cast<const afps::protocol::HitConfirmedFxT *>(value) : nullptr;
  }
  afps::protocol::KillFeedFxT *AsKillFeedFx() {
    return type == FxEvent::KillFeedFx ?
      reinterpret_cast<afps::protocol::KillFeedFxT *>(value) : nullptr;
  }
  const afps::protocol::KillFeedFxT *AsKillFeedFx() const {
    return type == FxEvent::KillFeedFx ?
      reinterpret_cast<const afps::protocol::KillFeedFxT *>(value) : nullptr;
  }
  afps::protocol::ProjectileSpawnFxT *AsProjectileSpawnFx() {
    return type == FxEvent::ProjectileSpawnFx ?
      reinterpret_cast<afps::protocol::ProjectileSpawnFxT *>(value) : nullptr;
  }
  const afps::protocol::ProjectileSpawnFxT *AsProjectileSpawnFx() const {
    return type == FxEvent::ProjectileSpawnFx ?
      reinterpret_cast<const afps::protocol::ProjectileSpawnFxT *>(value) : nullptr;
  }
  afps::protocol::ProjectileImpactFxT *AsProjectileImpactFx() {
    return type == FxEvent::ProjectileImpactFx ?
      reinterpret_cast<afps::protocol::ProjectileImpactFxT *>(value) : nullptr;
  }
  const afps::protocol::ProjectileImpactFxT *AsProjectileImpactFx() const {
    return type == FxEvent::ProjectileImpactFx ?
      reinterpret_cast<const afps::protocol::ProjectileImpactFxT *>(value) : nullptr;
  }
  afps::protocol::ProjectileRemoveFxT *AsProjectileRemoveFx() {
    return type == FxEvent::ProjectileRemoveFx ?
      reinterpret_cast<afps::protocol::ProjectileRemoveFxT *>(value) : nullptr;
  }
  const afps::protocol::ProjectileRemoveFxT *AsProjectileRemoveFx() const {
    return type == FxEvent::ProjectileRemoveFx ?
      reinterpret_cast<const afps::protocol::ProjectileRemoveFxT *>(value) : nullptr;
  }
  afps::protocol::PickupSpawnedFxT *AsPickupSpawnedFx() {
    return type == FxEvent::PickupSpawnedFx ?
      reinterpret_cast<afps::protocol::PickupSpawnedFxT *>(value) : nullptr;
  }
  const afps::protocol::PickupSpawnedFxT *AsPickupSpawnedFx() const {
    return type == FxEvent::PickupSpawnedFx ?
      reinterpret_cast<const afps::protocol::PickupSpawnedFxT *>(value) : nullptr;
  }
  afps::protocol::PickupTakenFxT *AsPickupTakenFx() {
    return type == FxEvent::PickupTakenFx ?
      reinterpret_cast<afps::protocol::PickupTakenFxT *>(value) : nullptr;
  }
  const afps::protocol::PickupTakenFxT *AsPickupTakenFx() const {
    return type == FxEvent::PickupTakenFx ?
      reinterpret_cast<const afps::protocol::PickupTakenFxT *>(value) : nullptr;
  }
};

template <bool B = false>
bool VerifyFxEvent(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, FxEvent type);
template <bool B = false>
bool VerifyFxEventVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<FxEvent> *types);

struct ShotFiredFxT : public ::flatbuffers::NativeTable {
  typedef ShotFiredFx TableType;
  std::string shooter_id{};
  uint8_t weapon_slot = 0;
  int32_t shot_seq = 0;
  bool dry_fire = false;
};

struct ShotFiredFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShotFiredFxT NativeTableType;
  typedef ShotFiredFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_WEAPON_SLOT = 6,
    VT_SHOT_SEQ = 8,
    VT_DRY_FIRE = 10
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  uint8_t weapon_slot() const {
    return GetField<uint8_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t shot_seq() const {
    return GetField<int32_t>(VT_SHOT_SEQ, 0);
  }
  bool dry_fire() const {
    return GetField<uint8_t>(VT_DRY_FIRE, 0) != 0;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON_SLOT, 1) &&
           VerifyField<int32_t>(verifier, VT_SHOT_SEQ, 4) &&
           VerifyField<uint8_t>(verifier, VT_DRY_FIRE, 1) &&
           verifier.EndTable();
  }
  ShotFiredFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShotFiredFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ShotFiredFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ShotFiredFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShotFiredFxBuilder {
  typedef ShotFiredFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(ShotFiredFx::VT_SHOOTER_ID, shooter_id);
  }
  void add_weapon_slot(uint8_t weapon_slot) {
    fbb_.AddElement<uint8_t>(ShotFiredFx::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_shot_seq(int32_t shot_seq) {
    fbb_.AddElement<int32_t>(ShotFiredFx::VT_SHOT_SEQ, shot_seq, 0);
  }
  void add_dry_fire(bool dry_fire) {
    fbb_.AddElement<uint8_t>(ShotFiredFx::VT_DRY_FIRE, static_cast<uint8_t>(dry_fire), 0);
  }
  explicit ShotFiredFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShotFiredFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShotFiredFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShotFiredFx> CreateShotFiredFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    uint8_t weapon_slot = 0,
    int32_t shot_seq = 0,
    bool dry_fire = false) {
  ShotFiredFxBuilder builder_(_fbb);
  builder_.add_shot_seq(shot_seq);
  builder_.add_shooter_id(shooter_id);
  builder_.add_dry_fire(dry_fire);
  builder_.add_weapon_slot(weapon_slot);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShotFiredFx> CreateShotFiredFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    uint8_t weapon_slot = 0,
    int32_t shot_seq = 0,
    bool dry_fire = false) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  return afps::protocol::CreateShotFiredFx(
      _fbb,
      shooter_id__,
      weapon_slot,
      shot_seq,
      dry_fire);
}

::flatbuffers::Offset<ShotFiredFx> CreateShotFiredFx(::flatbuffers::FlatBufferBuilder &_fbb, const ShotFiredFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShotTraceFxT : public ::flatbuffers::NativeTable {
  typedef ShotTraceFx TableType;
  std::string shooter_id{};
  uint8_t weapon_slot = 0;
  int32_t shot_seq = 0;
  int16_t dir_oct_x = 0;
  int16_t dir_oct_y = 0;
  uint16_t hit_dist_q = 0;
  afps::protocol::HitKind hit_kind = afps::protocol::HitKind::None;
  afps::protocol::SurfaceType surface_type = afps::protocol::SurfaceType::Stone;
  int16_t normal_oct_x = 0;
  int16_t normal_oct_y = 0;
  bool show_tracer = false;
  int16_t hit_pos_x_q = 0;
  int16_t hit_pos_y_q = 0;
  int16_t hit_pos_z_q = 0;
};

struct ShotTraceFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShotTraceFxT NativeTableType;
  typedef ShotTraceFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_WEAPON_SLOT = 6,
    VT_SHOT_SEQ = 8,
    VT_DIR_OCT_X = 10,
    VT_DIR_OCT_Y = 12,
    VT_HIT_DIST_Q = 14,
    VT_HIT_KIND = 16,
    VT_SURFACE_TYPE = 18,
    VT_NORMAL_OCT_X = 20,
    VT_NORMAL_OCT_Y = 22,
    VT_SHOW_TRACER = 24,
    VT_HIT_POS_X_Q = 26,
    VT_HIT_POS_Y_Q = 28,
    VT_HIT_POS_Z_Q = 30
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  uint8_t weapon_slot() const {
    return GetField<uint8_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t shot_seq() const {
    return GetField<int32_t>(VT_SHOT_SEQ, 0);
  }
  int16_t dir_oct_x() const {
    return GetField<int16_t>(VT_DIR_OCT_X, 0);
  }
  int16_t dir_oct_y() const {
    return GetField<int16_t>(VT_DIR_OCT_Y, 0);
  }
  uint16_t hit_dist_q() const {
    return GetField<uint16_t>(VT_HIT_DIST_Q, 0);
  }
  afps::protocol::HitKind hit_kind() const {
    return static_cast<afps::protocol::HitKind>(GetField<uint8_t>(VT_HIT_KIND, 0));
  }
  afps::protocol::SurfaceType surface_type() const {
    return static_cast<afps::protocol::SurfaceType>(GetField<uint8_t>(VT_SURFACE_TYPE, 0));
  }
  int16_t normal_oct_x() const {
    return GetField<int16_t>(VT_NORMAL_OCT_X, 0);
  }
  int16_t normal_oct_y() const {
    return GetField<int16_t>(VT_NORMAL_OCT_Y, 0);
  }
  bool show_tracer() const {
    return GetField<uint8_t>(VT_SHOW_TRACER, 0) != 0;
  }
  int16_t hit_pos_x_q() const {
    return GetField<int16_t>(VT_HIT_POS_X_Q, 0);
  }
  int16_t hit_pos_y_q() const {
    return GetField<int16_t>(VT_HIT_POS_Y_Q, 0);
  }
  int16_t hit_pos_z_q() const {
    return GetField<int16_t>(VT_HIT_POS_Z_Q, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON_SLOT, 1) &&
           VerifyField<int32_t>(verifier, VT_SHOT_SEQ, 4) &&
           VerifyField<int16_t>(verifier, VT_DIR_OCT_X, 2) &&
           VerifyField<int16_t>(verifier, VT_DIR_OCT_Y, 2) &&
           VerifyField<uint16_t>(verifier, VT_HIT_DIST_Q, 2) &&
           VerifyField<uint8_t>(verifier, VT_HIT_KIND, 1) &&
           VerifyField<uint8_t>(verifier, VT_SURFACE_TYPE, 1) &&
           VerifyField<int16_t>(verifier, VT_NORMAL_OCT_X, 2) &&
           VerifyField<int16_t>(verifier, VT_NORMAL_OCT_Y, 2) &&
           VerifyField<uint8_t>(verifier, VT_SHOW_TRACER, 1) &&
           VerifyField<int16_t>(verifier, VT_HIT_POS_X_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_HIT_POS_Y_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_HIT_POS_Z_Q, 2) &&
           verifier.EndTable();
  }
  ShotTraceFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShotTraceFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ShotTraceFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ShotTraceFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShotTraceFxBuilder {
  typedef ShotTraceFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(ShotTraceFx::VT_SHOOTER_ID, shooter_id);
  }
  void add_weapon_slot(uint8_t weapon_slot) {
    fbb_.AddElement<uint8_t>(ShotTraceFx::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_shot_seq(int32_t shot_seq) {
    fbb_.AddElement<int32_t>(ShotTraceFx::VT_SHOT_SEQ, shot_seq, 0);
  }
  void add_dir_oct_x(int16_t dir_oct_x) {
    fbb_.AddElement<int16_t>(ShotTraceFx::VT_DIR_OCT_X, dir_oct_x, 0);
  }
  void add_dir_oct_y(int16_t dir_oct_y) {
    fbb_.AddElement<int16_t>(ShotTraceFx::VT_DIR_OCT_Y, dir_oct_y, 0);
  }
  void add_hit_dist_q(uint16_t hit_dist_q) {
    fbb_.AddElement<uint16_t>(ShotTraceFx::VT_HIT_DIST_Q, hit_dist_q, 0);
  }
  void add_hit_kind(afps::protocol::HitKind hit_kind) {
    fbb_.AddElement<uint8_t>(ShotTraceFx::VT_HIT_KIND, static_cast<uint8_t>(hit_kind), 0);
  }
  void add_surface_type(afps::protocol::SurfaceType surface_type) {
    fbb_.AddElement<uint8_t>(ShotTraceFx::VT_SURFACE_TYPE, static_cast<uint8_t>(surface_type), 0);
  }
  void add_normal_oct_x(int16_t normal_oct_x) {
    fbb_.AddElement<int16_t>(ShotTraceFx::VT_NORMAL_OCT_X, normal_oct_x, 0);
  }
  void add_normal_oct_y(int16_t normal_oct_y) {
    fbb_.AddElement<int16_t>(ShotTraceFx::VT_NORMAL_OCT_Y, normal_oct_y, 0);
  }
  void add_show_tracer(bool show_tracer) {
    fbb_.AddElement<uint8_t>(ShotTraceFx::VT_SHOW_TRACER, static_cast<uint8_t>(show_tracer), 0);
  }
  void add_hit_pos_x_q(int16_t hit_pos_x_q) {
    fbb_.AddElement<int16_t>(ShotTraceFx::VT_HIT_POS_X_Q, hit_pos_x_q, 0);
  }
  void add_hit_pos_y_q(int16_t hit_pos_y_q) {
    fbb_.AddElement<int16_t>(ShotTraceFx::VT_HIT_POS_Y_Q, hit_pos_y_q, 0);
  }
  void add_hit_pos_z_q(int16_t hit_pos_z_q) {
    fbb_.AddElement<int16_t>(ShotTraceFx::VT_HIT_POS_Z_Q, hit_pos_z_q, 0);
  }
  explicit ShotTraceFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShotTraceFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShotTraceFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShotTraceFx> CreateShotTraceFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    uint8_t weapon_slot = 0,
    int32_t shot_seq = 0,
    int16_t dir_oct_x = 0,
    int16_t dir_oct_y = 0,
    uint16_t hit_dist_q = 0,
    afps::protocol::HitKind hit_kind = afps::protocol::HitKind::None,
    afps::protocol::SurfaceType surface_type = afps::protocol::SurfaceType::Stone,
    int16_t normal_oct_x = 0,
    int16_t normal_oct_y = 0,
    bool show_tracer = false,
    int16_t hit_pos_x_q = 0,
    int16_t hit_pos_y_q = 0,
    int16_t hit_pos_z_q = 0) {
  ShotTraceFxBuilder builder_(_fbb);
  builder_.add_shot_seq(shot_seq);
  builder_.add_shooter_id(shooter_id);
  builder_.add_hit_pos_z_q(hit_pos_z_q);
  builder_.add_hit_pos_y_q(hit_pos_y_q);
  builder_.add_hit_pos_x_q(hit_pos_x_q);
  builder_.add_normal_oct_y(normal_oct_y);
  builder_.add_normal_oct_x(normal_oct_x);
  builder_.add_hit_dist_q(hit_dist_q);
  builder_.add_dir_oct_y(dir_oct_y);
  builder_.add_dir_oct_x(dir_oct_x);
  builder_.add_show_tracer(show_tracer);
  builder_.add_surface_type(surface_type);
  builder_.add_hit_kind(hit_kind);
  builder_.add_weapon_slot(weapon_slot);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShotTraceFx> CreateShotTraceFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    uint8_t weapon_slot = 0,
    int32_t shot_seq = 0,
    int16_t dir_oct_x = 0,
    int16_t dir_oct_y = 0,
    uint16_t hit_dist_q = 0,
    afps::protocol::HitKind hit_kind = afps::protocol::HitKind::None,
    afps::protocol::SurfaceType surface_type = afps::protocol::SurfaceType::Stone,
    int16_t normal_oct_x = 0,
    int16_t normal_oct_y = 0,
    bool show_tracer = false,
    int16_t hit_pos_x_q = 0,
    int16_t hit_pos_y_q = 0,
    int16_t hit_pos_z_q = 0) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  return afps::protocol::CreateShotTraceFx(
      _fbb,
      shooter_id__,
      weapon_slot,
      shot_seq,
      dir_oct_x,
      dir_oct_y,
      hit_dist_q,
      hit_kind,
      surface_type,
      normal_oct_x,
      normal_oct_y,
      show_tracer,
      hit_pos_x_q,
      hit_pos_y_q,
      hit_pos_z_q);
}

::flatbuffers::Offset<ShotTraceFx> CreateShotTraceFx(::flatbuffers::FlatBufferBuilder &_fbb, const ShotTraceFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReloadFxT : public ::flatbuffers::NativeTable {
  typedef ReloadFx TableType;
  std::string shooter_id{};
  uint8_t weapon_slot = 0;
};

struct ReloadFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReloadFxT NativeTableType;
  typedef ReloadFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_WEAPON_SLOT = 6
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  uint8_t weapon_slot() const {
    return GetField<uint8_t>(VT_WEAPON_SLOT, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON_SLOT, 1) &&
           verifier.EndTable();
  }
  ReloadFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReloadFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReloadFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReloadFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReloadFxBuilder {
  typedef ReloadFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(ReloadFx::VT_SHOOTER_ID, shooter_id);
  }
  void add_weapon_slot(uint8_t weapon_slot) {
    fbb_.AddElement<uint8_t>(ReloadFx::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  explicit ReloadFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReloadFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReloadFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReloadFx> CreateReloadFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    uint8_t weapon_slot = 0) {
  ReloadFxBuilder builder_(_fbb);
  builder_.add_shooter_id(shooter_id);
  builder_.add_weapon_slot(weapon_slot);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReloadFx> CreateReloadFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    uint8_t weapon_slot = 0) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  return afps::protocol::CreateReloadFx(
      _fbb,
      shooter_id__,
      weapon_slot);
}

::flatbuffers::Offset<ReloadFx> CreateReloadFx(::flatbuffers::FlatBufferBuilder &_fbb, const ReloadFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NearMissFxT : public ::flatbuffers::NativeTable {
  typedef NearMissFx TableType;
  std::string shooter_id{};
  int32_t shot_seq = 0;
  uint8_t strength = 0;
};

struct NearMissFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NearMissFxT NativeTableType;
  typedef NearMissFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_SHOT_SEQ = 6,
    VT_STRENGTH = 8
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  int32_t shot_seq() const {
    return GetField<int32_t>(VT_SHOT_SEQ, 0);
  }
  uint8_t strength() const {
    return GetField<uint8_t>(VT_STRENGTH, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyField<int32_t>(verifier, VT_SHOT_SEQ, 4) &&
           VerifyField<uint8_t>(verifier, VT_STRENGTH, 1) &&
           verifier.EndTable();
  }
  NearMissFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NearMissFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NearMissFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NearMissFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NearMissFxBuilder {
  typedef NearMissFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(NearMissFx::VT_SHOOTER_ID, shooter_id);
  }
  void add_shot_seq(int32_t shot_seq) {
    fbb_.AddElement<int32_t>(NearMissFx::VT_SHOT_SEQ, shot_seq, 0);
  }
  void add_strength(uint8_t strength) {
    fbb_.AddElement<uint8_t>(NearMissFx::VT_STRENGTH, strength, 0);
  }
  explicit NearMissFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NearMissFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NearMissFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NearMissFx> CreateNearMissFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    int32_t shot_seq = 0,
    uint8_t strength = 0) {
  NearMissFxBuilder builder_(_fbb);
  builder_.add_shot_seq(shot_seq);
  builder_.add_shooter_id(shooter_id);
  builder_.add_strength(strength);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NearMissFx> CreateNearMissFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    int32_t shot_seq = 0,
    uint8_t strength = 0) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  return afps::protocol::CreateNearMissFx(
      _fbb,
      shooter_id__,
      shot_seq,
      strength);
}

::flatbuffers::Offset<NearMissFx> CreateNearMissFx(::flatbuffers::FlatBufferBuilder &_fbb, const NearMissFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OverheatFxT : public ::flatbuffers::NativeTable {
  typedef OverheatFx TableType;
  std::string shooter_id{};
  uint8_t weapon_slot = 0;
  uint16_t heat_q = 0;
};

struct OverheatFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OverheatFxT NativeTableType;
  typedef OverheatFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_WEAPON_SLOT = 6,
    VT_HEAT_Q = 8
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  uint8_t weapon_slot() const {
    return GetField<uint8_t>(VT_WEAPON_SLOT, 0);
  }
  uint16_t heat_q() const {
    return GetField<uint16_t>(VT_HEAT_Q, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON_SLOT, 1) &&
           VerifyField<uint16_t>(verifier, VT_HEAT_Q, 2) &&
           verifier.EndTable();
  }
  OverheatFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OverheatFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OverheatFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OverheatFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OverheatFxBuilder {
  typedef OverheatFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(OverheatFx::VT_SHOOTER_ID, shooter_id);
  }
  void add_weapon_slot(uint8_t weapon_slot) {
    fbb_.AddElement<uint8_t>(OverheatFx::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_heat_q(uint16_t heat_q) {
    fbb_.AddElement<uint16_t>(OverheatFx::VT_HEAT_Q, heat_q, 0);
  }
  explicit OverheatFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OverheatFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OverheatFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OverheatFx> CreateOverheatFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    uint8_t weapon_slot = 0,
    uint16_t heat_q = 0) {
  OverheatFxBuilder builder_(_fbb);
  builder_.add_shooter_id(shooter_id);
  builder_.add_heat_q(heat_q);
  builder_.add_weapon_slot(weapon_slot);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OverheatFx> CreateOverheatFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    uint8_t weapon_slot = 0,
    uint16_t heat_q = 0) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  return afps::protocol::CreateOverheatFx(
      _fbb,
      shooter_id__,
      weapon_slot,
      heat_q);
}

::flatbuffers::Offset<OverheatFx> CreateOverheatFx(::flatbuffers::FlatBufferBuilder &_fbb, const OverheatFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VentFxT : public ::flatbuffers::NativeTable {
  typedef VentFx TableType;
  std::string shooter_id{};
  uint8_t weapon_slot = 0;
};

struct VentFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VentFxT NativeTableType;
  typedef VentFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_WEAPON_SLOT = 6
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  uint8_t weapon_slot() const {
    return GetField<uint8_t>(VT_WEAPON_SLOT, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON_SLOT, 1) &&
           verifier.EndTable();
  }
  VentFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VentFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VentFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VentFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VentFxBuilder {
  typedef VentFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(VentFx::VT_SHOOTER_ID, shooter_id);
  }
  void add_weapon_slot(uint8_t weapon_slot) {
    fbb_.AddElement<uint8_t>(VentFx::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  explicit VentFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VentFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VentFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VentFx> CreateVentFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    uint8_t weapon_slot = 0) {
  VentFxBuilder builder_(_fbb);
  builder_.add_shooter_id(shooter_id);
  builder_.add_weapon_slot(weapon_slot);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VentFx> CreateVentFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    uint8_t weapon_slot = 0) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  return afps::protocol::CreateVentFx(
      _fbb,
      shooter_id__,
      weapon_slot);
}

::flatbuffers::Offset<VentFx> CreateVentFx(::flatbuffers::FlatBufferBuilder &_fbb, const VentFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HitConfirmedFxT : public ::flatbuffers::NativeTable {
  typedef HitConfirmedFx TableType;
  std::string target_id{};
  double damage = 0.0;
  bool killed = false;
};

struct HitConfirmedFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HitConfirmedFxT NativeTableType;
  typedef HitConfirmedFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_ID = 4,
    VT_DAMAGE = 6,
    VT_KILLED = 8
  };
  const ::flatbuffers::String *target_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_ID);
  }
  double damage() const {
    return GetField<double>(VT_DAMAGE, 0.0);
  }
  bool killed() const {
    return GetField<uint8_t>(VT_KILLED, 0) != 0;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET_ID) &&
           verifier.VerifyString(target_id()) &&
           VerifyField<double>(verifier, VT_DAMAGE, 8) &&
           VerifyField<uint8_t>(verifier, VT_KILLED, 1) &&
           verifier.EndTable();
  }
  HitConfirmedFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HitConfirmedFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HitConfirmedFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HitConfirmedFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HitConfirmedFxBuilder {
  typedef HitConfirmedFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_id(::flatbuffers::Offset<::flatbuffers::String> target_id) {
    fbb_.AddOffset(HitConfirmedFx::VT_TARGET_ID, target_id);
  }
  void add_damage(double damage) {
    fbb_.AddElement<double>(HitConfirmedFx::VT_DAMAGE, damage, 0.0);
  }
  void add_killed(bool killed) {
    fbb_.AddElement<uint8_t>(HitConfirmedFx::VT_KILLED, static_cast<uint8_t>(killed), 0);
  }
  explicit HitConfirmedFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HitConfirmedFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HitConfirmedFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HitConfirmedFx> CreateHitConfirmedFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> target_id = 0,
    double damage = 0.0,
    bool killed = false) {
  HitConfirmedFxBuilder builder_(_fbb);
  builder_.add_damage(damage);
  builder_.add_target_id(target_id);
  builder_.add_killed(killed);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HitConfirmedFx> CreateHitConfirmedFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *target_id = nullptr,
    double damage = 0.0,
    bool killed = false) {
  auto target_id__ = target_id ? _fbb.CreateString(target_id) : 0;
  return afps::protocol::CreateHitConfirmedFx(
      _fbb,
      target_id__,
      damage,
      killed);
}

::flatbuffers::Offset<HitConfirmedFx> CreateHitConfirmedFx(::flatbuffers::FlatBufferBuilder &_fbb, const HitConfirmedFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KillFeedFxT : public ::flatbuffers::NativeTable {
  typedef KillFeedFx TableType;
  std::string killer_id{};
  std::string victim_id{};
};

struct KillFeedFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KillFeedFxT NativeTableType;
  typedef KillFeedFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KILLER_ID = 4,
    VT_VICTIM_ID = 6
  };
  const ::flatbuffers::String *killer_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KILLER_ID);
  }
  const ::flatbuffers::String *victim_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VICTIM_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KILLER_ID) &&
           verifier.VerifyString(killer_id()) &&
           VerifyOffset(verifier, VT_VICTIM_ID) &&
           verifier.VerifyString(victim_id()) &&
           verifier.EndTable();
  }
  KillFeedFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KillFeedFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<KillFeedFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KillFeedFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KillFeedFxBuilder {
  typedef KillFeedFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_killer_id(::flatbuffers::Offset<::flatbuffers::String> killer_id) {
    fbb_.AddOffset(KillFeedFx::VT_KILLER_ID, killer_id);
  }
  void add_victim_id(::flatbuffers::Offset<::flatbuffers::String> victim_id) {
    fbb_.AddOffset(KillFeedFx::VT_VICTIM_ID, victim_id);
  }
  explicit KillFeedFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KillFeedFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KillFeedFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KillFeedFx> CreateKillFeedFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> killer_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> victim_id = 0) {
  KillFeedFxBuilder builder_(_fbb);
  builder_.add_victim_id(victim_id);
  builder_.add_killer_id(killer_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KillFeedFx> CreateKillFeedFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *killer_id = nullptr,
    const char *victim_id = nullptr) {
  auto killer_id__ = killer_id ? _fbb.CreateString(killer_id) : 0;
  auto victim_id__ = victim_id ? _fbb.CreateString(victim_id) : 0;
  return afps::protocol::CreateKillFeedFx(
      _fbb,
      killer_id__,
      victim_id__);
}

::flatbuffers::Offset<KillFeedFx> CreateKillFeedFx(::flatbuffers::FlatBufferBuilder &_fbb, const KillFeedFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProjectileSpawnFxT : public ::flatbuffers::NativeTable {
  typedef ProjectileSpawnFx TableType;
  std::string shooter_id{};
  uint8_t weapon_slot = 0;
  int32_t shot_seq = 0;
  int32_t projectile_id = 0;
  int16_t pos_x_q = 0;
  int16_t pos_y_q = 0;
  int16_t pos_z_q = 0;
  int16_t vel_x_q = 0;
  int16_t vel_y_q = 0;
  int16_t vel_z_q = 0;
  uint16_t ttl_q = 0;
};

struct ProjectileSpawnFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProjectileSpawnFxT NativeTableType;
  typedef ProjectileSpawnFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOOTER_ID = 4,
    VT_WEAPON_SLOT = 6,
    VT_SHOT_SEQ = 8,
    VT_PROJECTILE_ID = 10,
    VT_POS_X_Q = 12,
    VT_POS_Y_Q = 14,
    VT_POS_Z_Q = 16,
    VT_VEL_X_Q = 18,
    VT_VEL_Y_Q = 20,
    VT_VEL_Z_Q = 22,
    VT_TTL_Q = 24
  };
  const ::flatbuffers::String *shooter_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHOOTER_ID);
  }
  uint8_t weapon_slot() const {
    return GetField<uint8_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t shot_seq() const {
    return GetField<int32_t>(VT_SHOT_SEQ, 0);
  }
  int32_t projectile_id() const {
    return GetField<int32_t>(VT_PROJECTILE_ID, 0);
  }
  int16_t pos_x_q() const {
    return GetField<int16_t>(VT_POS_X_Q, 0);
  }
  int16_t pos_y_q() const {
    return GetField<int16_t>(VT_POS_Y_Q, 0);
  }
  int16_t pos_z_q() const {
    return GetField<int16_t>(VT_POS_Z_Q, 0);
  }
  int16_t vel_x_q() const {
    return GetField<int16_t>(VT_VEL_X_Q, 0);
  }
  int16_t vel_y_q() const {
    return GetField<int16_t>(VT_VEL_Y_Q, 0);
  }
  int16_t vel_z_q() const {
    return GetField<int16_t>(VT_VEL_Z_Q, 0);
  }
  uint16_t ttl_q() const {
    return GetField<uint16_t>(VT_TTL_Q, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHOOTER_ID) &&
           verifier.VerifyString(shooter_id()) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON_SLOT, 1) &&
           VerifyField<int32_t>(verifier, VT_SHOT_SEQ, 4) &&
           VerifyField<int32_t>(verifier, VT_PROJECTILE_ID, 4) &&
           VerifyField<int16_t>(verifier, VT_POS_X_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_POS_Y_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_POS_Z_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_VEL_X_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_VEL_Y_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_VEL_Z_Q, 2) &&
           VerifyField<uint16_t>(verifier, VT_TTL_Q, 2) &&
           verifier.EndTable();
  }
  ProjectileSpawnFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProjectileSpawnFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ProjectileSpawnFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileSpawnFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProjectileSpawnFxBuilder {
  typedef ProjectileSpawnFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shooter_id(::flatbuffers::Offset<::flatbuffers::String> shooter_id) {
    fbb_.AddOffset(ProjectileSpawnFx::VT_SHOOTER_ID, shooter_id);
  }
  void add_weapon_slot(uint8_t weapon_slot) {
    fbb_.AddElement<uint8_t>(ProjectileSpawnFx::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_shot_seq(int32_t shot_seq) {
    fbb_.AddElement<int32_t>(ProjectileSpawnFx::VT_SHOT_SEQ, shot_seq, 0);
  }
  void add_projectile_id(int32_t projectile_id) {
    fbb_.AddElement<int32_t>(ProjectileSpawnFx::VT_PROJECTILE_ID, projectile_id, 0);
  }
  void add_pos_x_q(int16_t pos_x_q) {
    fbb_.AddElement<int16_t>(ProjectileSpawnFx::VT_POS_X_Q, pos_x_q, 0);
  }
  void add_pos_y_q(int16_t pos_y_q) {
    fbb_.AddElement<int16_t>(ProjectileSpawnFx::VT_POS_Y_Q, pos_y_q, 0);
  }
  void add_pos_z_q(int16_t pos_z_q) {
    fbb_.AddElement<int16_t>(ProjectileSpawnFx::VT_POS_Z_Q, pos_z_q, 0);
  }
  void add_vel_x_q(int16_t vel_x_q) {
    fbb_.AddElement<int16_t>(ProjectileSpawnFx::VT_VEL_X_Q, vel_x_q, 0);
  }
  void add_vel_y_q(int16_t vel_y_q) {
    fbb_.AddElement<int16_t>(ProjectileSpawnFx::VT_VEL_Y_Q, vel_y_q, 0);
  }
  void add_vel_z_q(int16_t vel_z_q) {
    fbb_.AddElement<int16_t>(ProjectileSpawnFx::VT_VEL_Z_Q, vel_z_q, 0);
  }
  void add_ttl_q(uint16_t ttl_q) {
    fbb_.AddElement<uint16_t>(ProjectileSpawnFx::VT_TTL_Q, ttl_q, 0);
  }
  explicit ProjectileSpawnFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProjectileSpawnFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProjectileSpawnFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProjectileSpawnFx> CreateProjectileSpawnFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shooter_id = 0,
    uint8_t weapon_slot = 0,
    int32_t shot_seq = 0,
    int32_t projectile_id = 0,
    int16_t pos_x_q = 0,
    int16_t pos_y_q = 0,
    int16_t pos_z_q = 0,
    int16_t vel_x_q = 0,
    int16_t vel_y_q = 0,
    int16_t vel_z_q = 0,
    uint16_t ttl_q = 0) {
  ProjectileSpawnFxBuilder builder_(_fbb);
  builder_.add_projectile_id(projectile_id);
  builder_.add_shot_seq(shot_seq);
  builder_.add_shooter_id(shooter_id);
  builder_.add_ttl_q(ttl_q);
  builder_.add_vel_z_q(vel_z_q);
  builder_.add_vel_y_q(vel_y_q);
  builder_.add_vel_x_q(vel_x_q);
  builder_.add_pos_z_q(pos_z_q);
  builder_.add_pos_y_q(pos_y_q);
  builder_.add_pos_x_q(pos_x_q);
  builder_.add_weapon_slot(weapon_slot);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProjectileSpawnFx> CreateProjectileSpawnFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shooter_id = nullptr,
    uint8_t weapon_slot = 0,
    int32_t shot_seq = 0,
    int32_t projectile_id = 0,
    int16_t pos_x_q = 0,
    int16_t pos_y_q = 0,
    int16_t pos_z_q = 0,
    int16_t vel_x_q = 0,
    int16_t vel_y_q = 0,
    int16_t vel_z_q = 0,
    uint16_t ttl_q = 0) {
  auto shooter_id__ = shooter_id ? _fbb.CreateString(shooter_id) : 0;
  return afps::protocol::CreateProjectileSpawnFx(
      _fbb,
      shooter_id__,
      weapon_slot,
      shot_seq,
      projectile_id,
      pos_x_q,
      pos_y_q,
      pos_z_q,
      vel_x_q,
      vel_y_q,
      vel_z_q,
      ttl_q);
}

::flatbuffers::Offset<ProjectileSpawnFx> CreateProjectileSpawnFx(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileSpawnFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProjectileImpactFxT : public ::flatbuffers::NativeTable {
  typedef ProjectileImpactFx TableType;
  int32_t projectile_id = 0;
  bool hit_world = false;
  std::string target_id{};
  int16_t pos_x_q = 0;
  int16_t pos_y_q = 0;
  int16_t pos_z_q = 0;
  int16_t normal_oct_x = 0;
  int16_t normal_oct_y = 0;
  afps::protocol::SurfaceType surface_type = afps::protocol::SurfaceType::Stone;
};

struct ProjectileImpactFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProjectileImpactFxT NativeTableType;
  typedef ProjectileImpactFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROJECTILE_ID = 4,
    VT_HIT_WORLD = 6,
    VT_TARGET_ID = 8,
    VT_POS_X_Q = 10,
    VT_POS_Y_Q = 12,
    VT_POS_Z_Q = 14,
    VT_NORMAL_OCT_X = 16,
    VT_NORMAL_OCT_Y = 18,
    VT_SURFACE_TYPE = 20
  };
  int32_t projectile_id() const {
    return GetField<int32_t>(VT_PROJECTILE_ID, 0);
  }
  bool hit_world() const {
    return GetField<uint8_t>(VT_HIT_WORLD, 0) != 0;
  }
  const ::flatbuffers::String *target_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_ID);
  }
  int16_t pos_x_q() const {
    return GetField<int16_t>(VT_POS_X_Q, 0);
  }
  int16_t pos_y_q() const {
    return GetField<int16_t>(VT_POS_Y_Q, 0);
  }
  int16_t pos_z_q() const {
    return GetField<int16_t>(VT_POS_Z_Q, 0);
  }
  int16_t normal_oct_x() const {
    return GetField<int16_t>(VT_NORMAL_OCT_X, 0);
  }
  int16_t normal_oct_y() const {
    return GetField<int16_t>(VT_NORMAL_OCT_Y, 0);
  }
  afps::protocol::SurfaceType surface_type() const {
    return static_cast<afps::protocol::SurfaceType>(GetField<uint8_t>(VT_SURFACE_TYPE, 0));
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PROJECTILE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_HIT_WORLD, 1) &&
           VerifyOffset(verifier, VT_TARGET_ID) &&
           verifier.VerifyString(target_id()) &&
           VerifyField<int16_t>(verifier, VT_POS_X_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_POS_Y_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_POS_Z_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_NORMAL_OCT_X, 2) &&
           VerifyField<int16_t>(verifier, VT_NORMAL_OCT_Y, 2) &&
           VerifyField<uint8_t>(verifier, VT_SURFACE_TYPE, 1) &&
           verifier.EndTable();
  }
  ProjectileImpactFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProjectileImpactFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ProjectileImpactFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileImpactFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProjectileImpactFxBuilder {
  typedef ProjectileImpactFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_projectile_id(int32_t projectile_id) {
    fbb_.AddElement<int32_t>(ProjectileImpactFx::VT_PROJECTILE_ID, projectile_id, 0);
  }
  void add_hit_world(bool hit_world) {
    fbb_.AddElement<uint8_t>(ProjectileImpactFx::VT_HIT_WORLD, static_cast<uint8_t>(hit_world), 0);
  }
  void add_target_id(::flatbuffers::Offset<::flatbuffers::String> target_id) {
    fbb_.AddOffset(ProjectileImpactFx::VT_TARGET_ID, target_id);
  }
  void add_pos_x_q(int16_t pos_x_q) {
    fbb_.AddElement<int16_t>(ProjectileImpactFx::VT_POS_X_Q, pos_x_q, 0);
  }
  void add_pos_y_q(int16_t pos_y_q) {
    fbb_.AddElement<int16_t>(ProjectileImpactFx::VT_POS_Y_Q, pos_y_q, 0);
  }
  void add_pos_z_q(int16_t pos_z_q) {
    fbb_.AddElement<int16_t>(ProjectileImpactFx::VT_POS_Z_Q, pos_z_q, 0);
  }
  void add_normal_oct_x(int16_t normal_oct_x) {
    fbb_.AddElement<int16_t>(ProjectileImpactFx::VT_NORMAL_OCT_X, normal_oct_x, 0);
  }
  void add_normal_oct_y(int16_t normal_oct_y) {
    fbb_.AddElement<int16_t>(ProjectileImpactFx::VT_NORMAL_OCT_Y, normal_oct_y, 0);
  }
  void add_surface_type(afps::protocol::SurfaceType surface_type) {
    fbb_.AddElement<uint8_t>(ProjectileImpactFx::VT_SURFACE_TYPE, static_cast<uint8_t>(surface_type), 0);
  }
  explicit ProjectileImpactFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProjectileImpactFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProjectileImpactFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProjectileImpactFx> CreateProjectileImpactFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t projectile_id = 0,
    bool hit_world = false,
    ::flatbuffers::Offset<::flatbuffers::String> target_id = 0,
    int16_t pos_x_q = 0,
    int16_t pos_y_q = 0,
    int16_t pos_z_q = 0,
    int16_t normal_oct_x = 0,
    int16_t normal_oct_y = 0,
    afps::protocol::SurfaceType surface_type = afps::protocol::SurfaceType::Stone) {
  ProjectileImpactFxBuilder builder_(_fbb);
  builder_.add_target_id(target_id);
  builder_.add_projectile_id(projectile_id);
  builder_.add_normal_oct_y(normal_oct_y);
  builder_.add_normal_oct_x(normal_oct_x);
  builder_.add_pos_z_q(pos_z_q);
  builder_.add_pos_y_q(pos_y_q);
  builder_.add_pos_x_q(pos_x_q);
  builder_.add_surface_type(surface_type);
  builder_.add_hit_world(hit_world);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProjectileImpactFx> CreateProjectileImpactFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t projectile_id = 0,
    bool hit_world = false,
    const char *target_id = nullptr,
    int16_t pos_x_q = 0,
    int16_t pos_y_q = 0,
    int16_t pos_z_q = 0,
    int16_t normal_oct_x = 0,
    int16_t normal_oct_y = 0,
    afps::protocol::SurfaceType surface_type = afps::protocol::SurfaceType::Stone) {
  auto target_id__ = target_id ? _fbb.CreateString(target_id) : 0;
  return afps::protocol::CreateProjectileImpactFx(
      _fbb,
      projectile_id,
      hit_world,
      target_id__,
      pos_x_q,
      pos_y_q,
      pos_z_q,
      normal_oct_x,
      normal_oct_y,
      surface_type);
}

::flatbuffers::Offset<ProjectileImpactFx> CreateProjectileImpactFx(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileImpactFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProjectileRemoveFxT : public ::flatbuffers::NativeTable {
  typedef ProjectileRemoveFx TableType;
  int32_t projectile_id = 0;
};

struct ProjectileRemoveFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProjectileRemoveFxT NativeTableType;
  typedef ProjectileRemoveFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROJECTILE_ID = 4
  };
  int32_t projectile_id() const {
    return GetField<int32_t>(VT_PROJECTILE_ID, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PROJECTILE_ID, 4) &&
           verifier.EndTable();
  }
  ProjectileRemoveFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProjectileRemoveFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ProjectileRemoveFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileRemoveFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProjectileRemoveFxBuilder {
  typedef ProjectileRemoveFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_projectile_id(int32_t projectile_id) {
    fbb_.AddElement<int32_t>(ProjectileRemoveFx::VT_PROJECTILE_ID, projectile_id, 0);
  }
  explicit ProjectileRemoveFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProjectileRemoveFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProjectileRemoveFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProjectileRemoveFx> CreateProjectileRemoveFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t projectile_id = 0) {
  ProjectileRemoveFxBuilder builder_(_fbb);
  builder_.add_projectile_id(projectile_id);
  return builder_.Finish();
}

::flatbuffers::Offset<ProjectileRemoveFx> CreateProjectileRemoveFx(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileRemoveFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PickupSpawnedFxT : public ::flatbuffers::NativeTable {
  typedef PickupSpawnedFx TableType;
  uint32_t pickup_id = 0;
  afps::protocol::PickupKind kind = afps::protocol::PickupKind::None;
  int16_t pos_x_q = 0;
  int16_t pos_y_q = 0;
  int16_t pos_z_q = 0;
  uint8_t weapon_slot = 0;
  uint16_t amount = 0;
};

struct PickupSpawnedFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PickupSpawnedFxT NativeTableType;
  typedef PickupSpawnedFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PICKUP_ID = 4,
    VT_KIND = 6,
    VT_POS_X_Q = 8,
    VT_POS_Y_Q = 10,
    VT_POS_Z_Q = 12,
    VT_WEAPON_SLOT = 14,
    VT_AMOUNT = 16
  };
  uint32_t pickup_id() const {
    return GetField<uint32_t>(VT_PICKUP_ID, 0);
  }
  afps::protocol::PickupKind kind() const {
    return static_cast<afps::protocol::PickupKind>(GetField<uint8_t>(VT_KIND, 0));
  }
  int16_t pos_x_q() const {
    return GetField<int16_t>(VT_POS_X_Q, 0);
  }
  int16_t pos_y_q() const {
    return GetField<int16_t>(VT_POS_Y_Q, 0);
  }
  int16_t pos_z_q() const {
    return GetField<int16_t>(VT_POS_Z_Q, 0);
  }
  uint8_t weapon_slot() const {
    return GetField<uint8_t>(VT_WEAPON_SLOT, 0);
  }
  uint16_t amount() const {
    return GetField<uint16_t>(VT_AMOUNT, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PICKUP_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_KIND, 1) &&
           VerifyField<int16_t>(verifier, VT_POS_X_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_POS_Y_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_POS_Z_Q, 2) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON_SLOT, 1) &&
           VerifyField<uint16_t>(verifier, VT_AMOUNT, 2) &&
           verifier.EndTable();
  }
  PickupSpawnedFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PickupSpawnedFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PickupSpawnedFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PickupSpawnedFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PickupSpawnedFxBuilder {
  typedef PickupSpawnedFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pickup_id(uint32_t pickup_id) {
    fbb_.AddElement<uint32_t>(PickupSpawnedFx::VT_PICKUP_ID, pickup_id, 0);
  }
  void add_kind(afps::protocol::PickupKind kind) {
    fbb_.AddElement<uint8_t>(PickupSpawnedFx::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_pos_x_q(int16_t pos_x_q) {
    fbb_.AddElement<int16_t>(PickupSpawnedFx::VT_POS_X_Q, pos_x_q, 0);
  }
  void add_pos_y_q(int16_t pos_y_q) {
    fbb_.AddElement<int16_t>(PickupSpawnedFx::VT_POS_Y_Q, pos_y_q, 0);
  }
  void add_pos_z_q(int16_t pos_z_q) {
    fbb_.AddElement<int16_t>(PickupSpawnedFx::VT_POS_Z_Q, pos_z_q, 0);
  }
  void add_weapon_slot(uint8_t weapon_slot) {
    fbb_.AddElement<uint8_t>(PickupSpawnedFx::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_amount(uint16_t amount) {
    fbb_.AddElement<uint16_t>(PickupSpawnedFx::VT_AMOUNT, amount, 0);
  }
  explicit PickupSpawnedFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PickupSpawnedFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PickupSpawnedFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PickupSpawnedFx> CreatePickupSpawnedFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t pickup_id = 0,
    afps::protocol::PickupKind kind = afps::protocol::PickupKind::None,
    int16_t pos_x_q = 0,
    int16_t pos_y_q = 0,
    int16_t pos_z_q = 0,
    uint8_t weapon_slot = 0,
    uint16_t amount = 0) {
  PickupSpawnedFxBuilder builder_(_fbb);
  builder_.add_pickup_id(pickup_id);
  builder_.add_amount(amount);
  builder_.add_pos_z_q(pos_z_q);
  builder_.add_pos_y_q(pos_y_q);
  builder_.add_pos_x_q(pos_x_q);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_kind(kind);
  return builder_.Finish();
}

::flatbuffers::Offset<PickupSpawnedFx> CreatePickupSpawnedFx(::flatbuffers::FlatBufferBuilder &_fbb, const PickupSpawnedFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PickupTakenFxT : public ::flatbuffers::NativeTable {
  typedef PickupTakenFx TableType;
  uint32_t pickup_id = 0;
  std::string taker_id{};
  int32_t server_tick = 0;
};

struct PickupTakenFx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PickupTakenFxT NativeTableType;
  typedef PickupTakenFxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PICKUP_ID = 4,
    VT_TAKER_ID = 6,
    VT_SERVER_TICK = 8
  };
  uint32_t pickup_id() const {
    return GetField<uint32_t>(VT_PICKUP_ID, 0);
  }
  const ::flatbuffers::String *taker_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAKER_ID);
  }
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PICKUP_ID, 4) &&
           VerifyOffset(verifier, VT_TAKER_ID) &&
           verifier.VerifyString(taker_id()) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           verifier.EndTable();
  }
  PickupTakenFxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PickupTakenFxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PickupTakenFx> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PickupTakenFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PickupTakenFxBuilder {
  typedef PickupTakenFx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pickup_id(uint32_t pickup_id) {
    fbb_.AddElement<uint32_t>(PickupTakenFx::VT_PICKUP_ID, pickup_id, 0);
  }
  void add_taker_id(::flatbuffers::Offset<::flatbuffers::String> taker_id) {
    fbb_.AddOffset(PickupTakenFx::VT_TAKER_ID, taker_id);
  }
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(PickupTakenFx::VT_SERVER_TICK, server_tick, 0);
  }
  explicit PickupTakenFxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PickupTakenFx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PickupTakenFx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PickupTakenFx> CreatePickupTakenFx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t pickup_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taker_id = 0,
    int32_t server_tick = 0) {
  PickupTakenFxBuilder builder_(_fbb);
  builder_.add_server_tick(server_tick);
  builder_.add_taker_id(taker_id);
  builder_.add_pickup_id(pickup_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PickupTakenFx> CreatePickupTakenFxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t pickup_id = 0,
    const char *taker_id = nullptr,
    int32_t server_tick = 0) {
  auto taker_id__ = taker_id ? _fbb.CreateString(taker_id) : 0;
  return afps::protocol::CreatePickupTakenFx(
      _fbb,
      pickup_id,
      taker_id__,
      server_tick);
}

::flatbuffers::Offset<PickupTakenFx> CreatePickupTakenFx(::flatbuffers::FlatBufferBuilder &_fbb, const PickupTakenFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClientHelloT : public ::flatbuffers::NativeTable {
  typedef ClientHello TableType;
  uint16_t protocol_version = 0;
  std::string session_token{};
  std::string connection_id{};
  std::string build{};
  std::string nickname{};
  std::string character_id{};
};

struct ClientHello FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientHelloT NativeTableType;
  typedef ClientHelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_SESSION_TOKEN = 6,
    VT_CONNECTION_ID = 8,
    VT_BUILD = 10,
    VT_NICKNAME = 12,
    VT_CHARACTER_ID = 14
  };
  uint16_t protocol_version() const {
    return GetField<uint16_t>(VT_PROTOCOL_VERSION, 0);
  }
  const ::flatbuffers::String *session_token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_TOKEN);
  }
  const ::flatbuffers::String *connection_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONNECTION_ID);
  }
  const ::flatbuffers::String *build() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BUILD);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  const ::flatbuffers::String *character_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARACTER_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROTOCOL_VERSION, 2) &&
           VerifyOffset(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyString(session_token()) &&
           VerifyOffset(verifier, VT_CONNECTION_ID) &&
           verifier.VerifyString(connection_id()) &&
           VerifyOffset(verifier, VT_BUILD) &&
           verifier.VerifyString(build()) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           VerifyOffset(verifier, VT_CHARACTER_ID) &&
           verifier.VerifyString(character_id()) &&
           verifier.EndTable();
  }
  ClientHelloT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClientHelloT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ClientHello> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ClientHelloT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClientHelloBuilder {
  typedef ClientHello Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol_version(uint16_t protocol_version) {
    fbb_.AddElement<uint16_t>(ClientHello::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_session_token(::flatbuffers::Offset<::flatbuffers::String> session_token) {
    fbb_.AddOffset(ClientHello::VT_SESSION_TOKEN, session_token);
  }
  void add_connection_id(::flatbuffers::Offset<::flatbuffers::String> connection_id) {
    fbb_.AddOffset(ClientHello::VT_CONNECTION_ID, connection_id);
  }
  void add_build(::flatbuffers::Offset<::flatbuffers::String> build) {
    fbb_.AddOffset(ClientHello::VT_BUILD, build);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(ClientHello::VT_NICKNAME, nickname);
  }
  void add_character_id(::flatbuffers::Offset<::flatbuffers::String> character_id) {
    fbb_.AddOffset(ClientHello::VT_CHARACTER_ID, character_id);
  }
  explicit ClientHelloBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientHello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientHello>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientHello> CreateClientHello(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> session_token = 0,
    ::flatbuffers::Offset<::flatbuffers::String> connection_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> build = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> character_id = 0) {
  ClientHelloBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  builder_.add_nickname(nickname);
  builder_.add_build(build);
  builder_.add_connection_id(connection_id);
  builder_.add_session_token(session_token);
  builder_.add_protocol_version(protocol_version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ClientHello> CreateClientHelloDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol_version = 0,
    const char *session_token = nullptr,
    const char *connection_id = nullptr,
    const char *build = nullptr,
    const char *nickname = nullptr,
    const char *character_id = nullptr) {
  auto session_token__ = session_token ? _fbb.CreateString(session_token) : 0;
  auto connection_id__ = connection_id ? _fbb.CreateString(connection_id) : 0;
  auto build__ = build ? _fbb.CreateString(build) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  auto character_id__ = character_id ? _fbb.CreateString(character_id) : 0;
  return afps::protocol::CreateClientHello(
      _fbb,
      protocol_version,
      session_token__,
      connection_id__,
      build__,
      nickname__,
      character_id__);
}

::flatbuffers::Offset<ClientHello> CreateClientHello(::flatbuffers::FlatBufferBuilder &_fbb, const ClientHelloT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerHelloT : public ::flatbuffers::NativeTable {
  typedef ServerHello TableType;
  uint16_t protocol_version = 0;
  std::string connection_id{};
  std::string client_id{};
  uint16_t server_tick_rate = 0;
  uint16_t snapshot_rate = 0;
  uint16_t snapshot_keyframe_interval = 0;
  std::string motd{};
  std::string connection_nonce{};
  uint32_t map_seed = 0;
};

struct ServerHello FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerHelloT NativeTableType;
  typedef ServerHelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_CONNECTION_ID = 6,
    VT_CLIENT_ID = 8,
    VT_SERVER_TICK_RATE = 10,
    VT_SNAPSHOT_RATE = 12,
    VT_SNAPSHOT_KEYFRAME_INTERVAL = 14,
    VT_MOTD = 16,
    VT_CONNECTION_NONCE = 18,
    VT_MAP_SEED = 20
  };
  uint16_t protocol_version() const {
    return GetField<uint16_t>(VT_PROTOCOL_VERSION, 0);
  }
  const ::flatbuffers::String *connection_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONNECTION_ID);
  }
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  uint16_t server_tick_rate() const {
    return GetField<uint16_t>(VT_SERVER_TICK_RATE, 0);
  }
  uint16_t snapshot_rate() const {
    return GetField<uint16_t>(VT_SNAPSHOT_RATE, 0);
  }
  uint16_t snapshot_keyframe_interval() const {
    return GetField<uint16_t>(VT_SNAPSHOT_KEYFRAME_INTERVAL, 0);
  }
  const ::flatbuffers::String *motd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MOTD);
  }
  const ::flatbuffers::String *connection_nonce() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONNECTION_NONCE);
  }
  uint32_t map_seed() const {
    return GetField<uint32_t>(VT_MAP_SEED, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROTOCOL_VERSION, 2) &&
           VerifyOffset(verifier, VT_CONNECTION_ID) &&
           verifier.VerifyString(connection_id()) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyField<uint16_t>(verifier, VT_SERVER_TICK_RATE, 2) &&
           VerifyField<uint16_t>(verifier, VT_SNAPSHOT_RATE, 2) &&
           VerifyField<uint16_t>(verifier, VT_SNAPSHOT_KEYFRAME_INTERVAL, 2) &&
           VerifyOffset(verifier, VT_MOTD) &&
           verifier.VerifyString(motd()) &&
           VerifyOffset(verifier, VT_CONNECTION_NONCE) &&
           verifier.VerifyString(connection_nonce()) &&
           VerifyField<uint32_t>(verifier, VT_MAP_SEED, 4) &&
           verifier.EndTable();
  }
  ServerHelloT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerHelloT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ServerHello> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ServerHelloT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerHelloBuilder {
  typedef ServerHello Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol_version(uint16_t protocol_version) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_connection_id(::flatbuffers::Offset<::flatbuffers::String> connection_id) {
    fbb_.AddOffset(ServerHello::VT_CONNECTION_ID, connection_id);
  }
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(ServerHello::VT_CLIENT_ID, client_id);
  }
  void add_server_tick_rate(uint16_t server_tick_rate) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_SERVER_TICK_RATE, server_tick_rate, 0);
  }
  void add_snapshot_rate(uint16_t snapshot_rate) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_SNAPSHOT_RATE, snapshot_rate, 0);
  }
  void add_snapshot_keyframe_interval(uint16_t snapshot_keyframe_interval) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_SNAPSHOT_KEYFRAME_INTERVAL, snapshot_keyframe_interval, 0);
  }
  void add_motd(::flatbuffers::Offset<::flatbuffers::String> motd) {
    fbb_.AddOffset(ServerHello::VT_MOTD, motd);
  }
  void add_connection_nonce(::flatbuffers::Offset<::flatbuffers::String> connection_nonce) {
    fbb_.AddOffset(ServerHello::VT_CONNECTION_NONCE, connection_nonce);
  }
  void add_map_seed(uint32_t map_seed) {
    fbb_.AddElement<uint32_t>(ServerHello::VT_MAP_SEED, map_seed, 0);
  }
  explicit ServerHelloBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerHello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerHello>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerHello> CreateServerHello(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> connection_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    uint16_t server_tick_rate = 0,
    uint16_t snapshot_rate = 0,
    uint16_t snapshot_keyframe_interval = 0,
    ::flatbuffers::Offset<::flatbuffers::String> motd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> connection_nonce = 0,
    uint32_t map_seed = 0) {
  ServerHelloBuilder builder_(_fbb);
  builder_.add_map_seed(map_seed);
  builder_.add_connection_nonce(connection_nonce);
  builder_.add_motd(motd);
  builder_.add_client_id(client_id);
  builder_.add_connection_id(connection_id);
  builder_.add_snapshot_keyframe_interval(snapshot_keyframe_interval);
  builder_.add_snapshot_rate(snapshot_rate);
  builder_.add_server_tick_rate(server_tick_rate);
  builder_.add_protocol_version(protocol_version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ServerHello> CreateServerHelloDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol_version = 0,
    const char *connection_id = nullptr,
    const char *client_id = nullptr,
    uint16_t server_tick_rate = 0,
    uint16_t snapshot_rate = 0,
    uint16_t snapshot_keyframe_interval = 0,
    const char *motd = nullptr,
    const char *connection_nonce = nullptr,
    uint32_t map_seed = 0) {
  auto connection_id__ = connection_id ? _fbb.CreateString(connection_id) : 0;
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  auto motd__ = motd ? _fbb.CreateString(motd) : 0;
  auto connection_nonce__ = connection_nonce ? _fbb.CreateString(connection_nonce) : 0;
  return afps::protocol::CreateServerHello(
      _fbb,
      protocol_version,
      connection_id__,
      client_id__,
      server_tick_rate,
      snapshot_rate,
      snapshot_keyframe_interval,
      motd__,
      connection_nonce__,
      map_seed);
}

::flatbuffers::Offset<ServerHello> CreateServerHello(::flatbuffers::FlatBufferBuilder &_fbb, const ServerHelloT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinRequestT : public ::flatbuffers::NativeTable {
  typedef JoinRequest TableType;
  std::string nickname{};
  std::string character_id{};
};

struct JoinRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinRequestT NativeTableType;
  typedef JoinRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NICKNAME = 4,
    VT_CHARACTER_ID = 6
  };
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  const ::flatbuffers::String *character_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARACTER_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           VerifyOffset(verifier, VT_CHARACTER_ID) &&
           verifier.VerifyString(character_id()) &&
           verifier.EndTable();
  }
  JoinRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<JoinRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinRequestBuilder {
  typedef JoinRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(JoinRequest::VT_NICKNAME, nickname);
  }
  void add_character_id(::flatbuffers::Offset<::flatbuffers::String> character_id) {
    fbb_.AddOffset(JoinRequest::VT_CHARACTER_ID, character_id);
  }
  explicit JoinRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinRequest> CreateJoinRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> character_id = 0) {
  JoinRequestBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  builder_.add_nickname(nickname);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JoinRequest> CreateJoinRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *nickname = nullptr,
    const char *character_id = nullptr) {
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  auto character_id__ = character_id ? _fbb.CreateString(character_id) : 0;
  return afps::protocol::CreateJoinRequest(
      _fbb,
      nickname__,
      character_id__);
}

::flatbuffers::Offset<JoinRequest> CreateJoinRequest(::flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinAcceptT : public ::flatbuffers::NativeTable {
  typedef JoinAccept TableType;
  std::string client_id{};
};

struct JoinAccept FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinAcceptT NativeTableType;
  typedef JoinAcceptBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ID = 4
  };
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           verifier.EndTable();
  }
  JoinAcceptT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinAcceptT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<JoinAccept> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoinAcceptT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinAcceptBuilder {
  typedef JoinAccept Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(JoinAccept::VT_CLIENT_ID, client_id);
  }
  explicit JoinAcceptBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinAccept> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinAccept>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinAccept> CreateJoinAccept(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0) {
  JoinAcceptBuilder builder_(_fbb);
  builder_.add_client_id(client_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JoinAccept> CreateJoinAcceptDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *client_id = nullptr) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  return afps::protocol::CreateJoinAccept(
      _fbb,
      client_id__);
}

::flatbuffers::Offset<JoinAccept> CreateJoinAccept(::flatbuffers::FlatBufferBuilder &_fbb, const JoinAcceptT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputCmdT : public ::flatbuffers::NativeTable {
  typedef InputCmd TableType;
  int32_t input_seq = 0;
  double move_x = 0.0;
  double move_y = 0.0;
  double look_delta_x = 0.0;
  double look_delta_y = 0.0;
  double view_yaw = 0.0;
  double view_pitch = 0.0;
  int32_t weapon_slot = 0;
  bool jump = false;
  bool fire = false;
  bool ads = false;
  bool sprint = false;
  bool dash = false;
  bool grapple = false;
  bool shield = false;
  bool shockwave = false;
  bool crouch = false;
};

struct InputCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InputCmdT NativeTableType;
  typedef InputCmdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_SEQ = 4,
    VT_MOVE_X = 6,
    VT_MOVE_Y = 8,
    VT_LOOK_DELTA_X = 10,
    VT_LOOK_DELTA_Y = 12,
    VT_VIEW_YAW = 14,
    VT_VIEW_PITCH = 16,
    VT_WEAPON_SLOT = 18,
    VT_JUMP = 20,
    VT_FIRE = 22,
    VT_ADS = 24,
    VT_SPRINT = 26,
    VT_DASH = 28,
    VT_GRAPPLE = 30,
    VT_SHIELD = 32,
    VT_SHOCKWAVE = 34,
    VT_CROUCH = 36
  };
  int32_t input_seq() const {
    return GetField<int32_t>(VT_INPUT_SEQ, 0);
  }
  double move_x() const {
    return GetField<double>(VT_MOVE_X, 0.0);
  }
  double move_y() const {
    return GetField<double>(VT_MOVE_Y, 0.0);
  }
  double look_delta_x() const {
    return GetField<double>(VT_LOOK_DELTA_X, 0.0);
  }
  double look_delta_y() const {
    return GetField<double>(VT_LOOK_DELTA_Y, 0.0);
  }
  double view_yaw() const {
    return GetField<double>(VT_VIEW_YAW, 0.0);
  }
  double view_pitch() const {
    return GetField<double>(VT_VIEW_PITCH, 0.0);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  bool jump() const {
    return GetField<uint8_t>(VT_JUMP, 0) != 0;
  }
  bool fire() const {
    return GetField<uint8_t>(VT_FIRE, 0) != 0;
  }
  bool ads() const {
    return GetField<uint8_t>(VT_ADS, 0) != 0;
  }
  bool sprint() const {
    return GetField<uint8_t>(VT_SPRINT, 0) != 0;
  }
  bool dash() const {
    return GetField<uint8_t>(VT_DASH, 0) != 0;
  }
  bool grapple() const {
    return GetField<uint8_t>(VT_GRAPPLE, 0) != 0;
  }
  bool shield() const {
    return GetField<uint8_t>(VT_SHIELD, 0) != 0;
  }
  bool shockwave() const {
    return GetField<uint8_t>(VT_SHOCKWAVE, 0) != 0;
  }
  bool crouch() const {
    return GetField<uint8_t>(VT_CROUCH, 0) != 0;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INPUT_SEQ, 4) &&
           VerifyField<double>(verifier, VT_MOVE_X, 8) &&
           VerifyField<double>(verifier, VT_MOVE_Y, 8) &&
           VerifyField<double>(verifier, VT_LOOK_DELTA_X, 8) &&
           VerifyField<double>(verifier, VT_LOOK_DELTA_Y, 8) &&
           VerifyField<double>(verifier, VT_VIEW_YAW, 8) &&
           VerifyField<double>(verifier, VT_VIEW_PITCH, 8) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<uint8_t>(verifier, VT_JUMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_FIRE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ADS, 1) &&
           VerifyField<uint8_t>(verifier, VT_SPRINT, 1) &&
           VerifyField<uint8_t>(verifier, VT_DASH, 1) &&
           VerifyField<uint8_t>(verifier, VT_GRAPPLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHIELD, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHOCKWAVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CROUCH, 1) &&
           verifier.EndTable();
  }
  InputCmdT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputCmdT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<InputCmd> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InputCmdT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputCmdBuilder {
  typedef InputCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_seq(int32_t input_seq) {
    fbb_.AddElement<int32_t>(InputCmd::VT_INPUT_SEQ, input_seq, 0);
  }
  void add_move_x(double move_x) {
    fbb_.AddElement<double>(InputCmd::VT_MOVE_X, move_x, 0.0);
  }
  void add_move_y(double move_y) {
    fbb_.AddElement<double>(InputCmd::VT_MOVE_Y, move_y, 0.0);
  }
  void add_look_delta_x(double look_delta_x) {
    fbb_.AddElement<double>(InputCmd::VT_LOOK_DELTA_X, look_delta_x, 0.0);
  }
  void add_look_delta_y(double look_delta_y) {
    fbb_.AddElement<double>(InputCmd::VT_LOOK_DELTA_Y, look_delta_y, 0.0);
  }
  void add_view_yaw(double view_yaw) {
    fbb_.AddElement<double>(InputCmd::VT_VIEW_YAW, view_yaw, 0.0);
  }
  void add_view_pitch(double view_pitch) {
    fbb_.AddElement<double>(InputCmd::VT_VIEW_PITCH, view_pitch, 0.0);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(InputCmd::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_jump(bool jump) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_JUMP, static_cast<uint8_t>(jump), 0);
  }
  void add_fire(bool fire) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_FIRE, static_cast<uint8_t>(fire), 0);
  }
  void add_ads(bool ads) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_ADS, static_cast<uint8_t>(ads), 0);
  }
  void add_sprint(bool sprint) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_SPRINT, static_cast<uint8_t>(sprint), 0);
  }
  void add_dash(bool dash) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_DASH, static_cast<uint8_t>(dash), 0);
  }
  void add_grapple(bool grapple) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_GRAPPLE, static_cast<uint8_t>(grapple), 0);
  }
  void add_shield(bool shield) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_SHIELD, static_cast<uint8_t>(shield), 0);
  }
  void add_shockwave(bool shockwave) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_SHOCKWAVE, static_cast<uint8_t>(shockwave), 0);
  }
  void add_crouch(bool crouch) {
    fbb_.AddElement<uint8_t>(InputCmd::VT_CROUCH, static_cast<uint8_t>(crouch), 0);
  }
  explicit InputCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InputCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InputCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InputCmd> CreateInputCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t input_seq = 0,
    double move_x = 0.0,
    double move_y = 0.0,
    double look_delta_x = 0.0,
    double look_delta_y = 0.0,
    double view_yaw = 0.0,
    double view_pitch = 0.0,
    int32_t weapon_slot = 0,
    bool jump = false,
    bool fire = false,
    bool ads = false,
    bool sprint = false,
    bool dash = false,
    bool grapple = false,
    bool shield = false,
    bool shockwave = false,
    bool crouch = false) {
  InputCmdBuilder builder_(_fbb);
  builder_.add_view_pitch(view_pitch);
  builder_.add_view_yaw(view_yaw);
  builder_.add_look_delta_y(look_delta_y);
  builder_.add_look_delta_x(look_delta_x);
  builder_.add_move_y(move_y);
  builder_.add_move_x(move_x);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_input_seq(input_seq);
  builder_.add_crouch(crouch);
  builder_.add_shockwave(shockwave);
  builder_.add_shield(shield);
  builder_.add_grapple(grapple);
  builder_.add_dash(dash);
  builder_.add_sprint(sprint);
  builder_.add_ads(ads);
  builder_.add_fire(fire);
  builder_.add_jump(jump);
  return builder_.Finish();
}

::flatbuffers::Offset<InputCmd> CreateInputCmd(::flatbuffers::FlatBufferBuilder &_fbb, const InputCmdT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FireWeaponRequestT : public ::flatbuffers::NativeTable {
  typedef FireWeaponRequest TableType;
  int32_t client_shot_seq = 0;
  std::string weapon_id{};
  int32_t weapon_slot = 0;
  double origin_x = 0.0;
  double origin_y = 0.0;
  double origin_z = 0.0;
  double dir_x = 0.0;
  double dir_y = 0.0;
  double dir_z = 0.0;
};

struct FireWeaponRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FireWeaponRequestT NativeTableType;
  typedef FireWeaponRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_SHOT_SEQ = 4,
    VT_WEAPON_ID = 6,
    VT_WEAPON_SLOT = 8,
    VT_ORIGIN_X = 10,
    VT_ORIGIN_Y = 12,
    VT_ORIGIN_Z = 14,
    VT_DIR_X = 16,
    VT_DIR_Y = 18,
    VT_DIR_Z = 20
  };
  int32_t client_shot_seq() const {
    return GetField<int32_t>(VT_CLIENT_SHOT_SEQ, 0);
  }
  const ::flatbuffers::String *weapon_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEAPON_ID);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  double origin_x() const {
    return GetField<double>(VT_ORIGIN_X, 0.0);
  }
  double origin_y() const {
    return GetField<double>(VT_ORIGIN_Y, 0.0);
  }
  double origin_z() const {
    return GetField<double>(VT_ORIGIN_Z, 0.0);
  }
  double dir_x() const {
    return GetField<double>(VT_DIR_X, 0.0);
  }
  double dir_y() const {
    return GetField<double>(VT_DIR_Y, 0.0);
  }
  double dir_z() const {
    return GetField<double>(VT_DIR_Z, 0.0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLIENT_SHOT_SEQ, 4) &&
           VerifyOffset(verifier, VT_WEAPON_ID) &&
           verifier.VerifyString(weapon_id()) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<double>(verifier, VT_ORIGIN_X, 8) &&
           VerifyField<double>(verifier, VT_ORIGIN_Y, 8) &&
           VerifyField<double>(verifier, VT_ORIGIN_Z, 8) &&
           VerifyField<double>(verifier, VT_DIR_X, 8) &&
           VerifyField<double>(verifier, VT_DIR_Y, 8) &&
           VerifyField<double>(verifier, VT_DIR_Z, 8) &&
           verifier.EndTable();
  }
  FireWeaponRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FireWeaponRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FireWeaponRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FireWeaponRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FireWeaponRequestBuilder {
  typedef FireWeaponRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_shot_seq(int32_t client_shot_seq) {
    fbb_.AddElement<int32_t>(FireWeaponRequest::VT_CLIENT_SHOT_SEQ, client_shot_seq, 0);
  }
  void add_weapon_id(::flatbuffers::Offset<::flatbuffers::String> weapon_id) {
    fbb_.AddOffset(FireWeaponRequest::VT_WEAPON_ID, weapon_id);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(FireWeaponRequest::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_origin_x(double origin_x) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_ORIGIN_X, origin_x, 0.0);
  }
  void add_origin_y(double origin_y) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_ORIGIN_Y, origin_y, 0.0);
  }
  void add_origin_z(double origin_z) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_ORIGIN_Z, origin_z, 0.0);
  }
  void add_dir_x(double dir_x) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_DIR_X, dir_x, 0.0);
  }
  void add_dir_y(double dir_y) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_DIR_Y, dir_y, 0.0);
  }
  void add_dir_z(double dir_z) {
    fbb_.AddElement<double>(FireWeaponRequest::VT_DIR_Z, dir_z, 0.0);
  }
  explicit FireWeaponRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FireWeaponRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FireWeaponRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FireWeaponRequest> CreateFireWeaponRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t client_shot_seq = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weapon_id = 0,
    int32_t weapon_slot = 0,
    double origin_x = 0.0,
    double origin_y = 0.0,
    double origin_z = 0.0,
    double dir_x = 0.0,
    double dir_y = 0.0,
    double dir_z = 0.0) {
  FireWeaponRequestBuilder builder_(_fbb);
  builder_.add_dir_z(dir_z);
  builder_.add_dir_y(dir_y);
  builder_.add_dir_x(dir_x);
  builder_.add_origin_z(origin_z);
  builder_.add_origin_y(origin_y);
  builder_.add_origin_x(origin_x);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_weapon_id(weapon_id);
  builder_.add_client_shot_seq(client_shot_seq);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FireWeaponRequest> CreateFireWeaponRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t client_shot_seq = 0,
    const char *weapon_id = nullptr,
    int32_t weapon_slot = 0,
    double origin_x = 0.0,
    double origin_y = 0.0,
    double origin_z = 0.0,
    double dir_x = 0.0,
    double dir_y = 0.0,
    double dir_z = 0.0) {
  auto weapon_id__ = weapon_id ? _fbb.CreateString(weapon_id) : 0;
  return afps::protocol::CreateFireWeaponRequest(
      _fbb,
      client_shot_seq,
      weapon_id__,
      weapon_slot,
      origin_x,
      origin_y,
      origin_z,
      dir_x,
      dir_y,
      dir_z);
}

::flatbuffers::Offset<FireWeaponRequest> CreateFireWeaponRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FireWeaponRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetLoadoutRequestT : public ::flatbuffers::NativeTable {
  typedef SetLoadoutRequest TableType;
  uint32_t loadout_bits = 0;
};

struct SetLoadoutRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetLoadoutRequestT NativeTableType;
  typedef SetLoadoutRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOADOUT_BITS = 4
  };
  uint32_t loadout_bits() const {
    return GetField<uint32_t>(VT_LOADOUT_BITS, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LOADOUT_BITS, 4) &&
           verifier.EndTable();
  }
  SetLoadoutRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetLoadoutRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetLoadoutRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetLoadoutRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetLoadoutRequestBuilder {
  typedef SetLoadoutRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_loadout_bits(uint32_t loadout_bits) {
    fbb_.AddElement<uint32_t>(SetLoadoutRequest::VT_LOADOUT_BITS, loadout_bits, 0);
  }
  explicit SetLoadoutRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetLoadoutRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetLoadoutRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetLoadoutRequest> CreateSetLoadoutRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t loadout_bits = 0) {
  SetLoadoutRequestBuilder builder_(_fbb);
  builder_.add_loadout_bits(loadout_bits);
  return builder_.Finish();
}

::flatbuffers::Offset<SetLoadoutRequest> CreateSetLoadoutRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SetLoadoutRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateSnapshotT : public ::flatbuffers::NativeTable {
  typedef StateSnapshot TableType;
  int32_t server_tick = 0;
  int32_t last_processed_input_seq = 0;
  std::string client_id{};
  double pos_x = 0.0;
  double pos_y = 0.0;
  double pos_z = 0.0;
  double vel_x = 0.0;
  double vel_y = 0.0;
  double vel_z = 0.0;
  int32_t weapon_slot = 0;
  int32_t ammo_in_mag = 0;
  double dash_cooldown = 0.0;
  double health = 0.0;
  int32_t kills = 0;
  int32_t deaths = 0;
  int16_t view_yaw_q = 0;
  int16_t view_pitch_q = 0;
  uint8_t player_flags = 0;
  uint16_t weapon_heat_q = 0;
  uint32_t loadout_bits = 0;
};

struct StateSnapshot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateSnapshotT NativeTableType;
  typedef StateSnapshotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_TICK = 4,
    VT_LAST_PROCESSED_INPUT_SEQ = 6,
    VT_CLIENT_ID = 8,
    VT_POS_X = 10,
    VT_POS_Y = 12,
    VT_POS_Z = 14,
    VT_VEL_X = 16,
    VT_VEL_Y = 18,
    VT_VEL_Z = 20,
    VT_WEAPON_SLOT = 22,
    VT_AMMO_IN_MAG = 24,
    VT_DASH_COOLDOWN = 26,
    VT_HEALTH = 28,
    VT_KILLS = 30,
    VT_DEATHS = 32,
    VT_VIEW_YAW_Q = 34,
    VT_VIEW_PITCH_Q = 36,
    VT_PLAYER_FLAGS = 38,
    VT_WEAPON_HEAT_Q = 40,
    VT_LOADOUT_BITS = 42
  };
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  int32_t last_processed_input_seq() const {
    return GetField<int32_t>(VT_LAST_PROCESSED_INPUT_SEQ, 0);
  }
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  double pos_x() const {
    return GetField<double>(VT_POS_X, 0.0);
  }
  double pos_y() const {
    return GetField<double>(VT_POS_Y, 0.0);
  }
  double pos_z() const {
    return GetField<double>(VT_POS_Z, 0.0);
  }
  double vel_x() const {
    return GetField<double>(VT_VEL_X, 0.0);
  }
  double vel_y() const {
    return GetField<double>(VT_VEL_Y, 0.0);
  }
  double vel_z() const {
    return GetField<double>(VT_VEL_Z, 0.0);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t ammo_in_mag() const {
    return GetField<int32_t>(VT_AMMO_IN_MAG, 0);
  }
  double dash_cooldown() const {
    return GetField<double>(VT_DASH_COOLDOWN, 0.0);
  }
  double health() const {
    return GetField<double>(VT_HEALTH, 0.0);
  }
  int32_t kills() const {
    return GetField<int32_t>(VT_KILLS, 0);
  }
  int32_t deaths() const {
    return GetField<int32_t>(VT_DEATHS, 0);
  }
  int16_t view_yaw_q() const {
    return GetField<int16_t>(VT_VIEW_YAW_Q, 0);
  }
  int16_t view_pitch_q() const {
    return GetField<int16_t>(VT_VIEW_PITCH_Q, 0);
  }
  uint8_t player_flags() const {
    return GetField<uint8_t>(VT_PLAYER_FLAGS, 0);
  }
  uint16_t weapon_heat_q() const {
    return GetField<uint16_t>(VT_WEAPON_HEAT_Q, 0);
  }
  uint32_t loadout_bits() const {
    return GetField<uint32_t>(VT_LOADOUT_BITS, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           VerifyField<int32_t>(verifier, VT_LAST_PROCESSED_INPUT_SEQ, 4) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyField<double>(verifier, VT_POS_X, 8) &&
           VerifyField<double>(verifier, VT_POS_Y, 8) &&
           VerifyField<double>(verifier, VT_POS_Z, 8) &&
           VerifyField<double>(verifier, VT_VEL_X, 8) &&
           VerifyField<double>(verifier, VT_VEL_Y, 8) &&
           VerifyField<double>(verifier, VT_VEL_Z, 8) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<int32_t>(verifier, VT_AMMO_IN_MAG, 4) &&
           VerifyField<double>(verifier, VT_DASH_COOLDOWN, 8) &&
           VerifyField<double>(verifier, VT_HEALTH, 8) &&
           VerifyField<int32_t>(verifier, VT_KILLS, 4) &&
           VerifyField<int32_t>(verifier, VT_DEATHS, 4) &&
           VerifyField<int16_t>(verifier, VT_VIEW_YAW_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_VIEW_PITCH_Q, 2) &&
           VerifyField<uint8_t>(verifier, VT_PLAYER_FLAGS, 1) &&
           VerifyField<uint16_t>(verifier, VT_WEAPON_HEAT_Q, 2) &&
           VerifyField<uint32_t>(verifier, VT_LOADOUT_BITS, 4) &&
           verifier.EndTable();
  }
  StateSnapshotT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateSnapshotT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StateSnapshot> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateSnapshotBuilder {
  typedef StateSnapshot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_SERVER_TICK, server_tick, 0);
  }
  void add_last_processed_input_seq(int32_t last_processed_input_seq) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_LAST_PROCESSED_INPUT_SEQ, last_processed_input_seq, 0);
  }
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(StateSnapshot::VT_CLIENT_ID, client_id);
  }
  void add_pos_x(double pos_x) {
    fbb_.AddElement<double>(StateSnapshot::VT_POS_X, pos_x, 0.0);
  }
  void add_pos_y(double pos_y) {
    fbb_.AddElement<double>(StateSnapshot::VT_POS_Y, pos_y, 0.0);
  }
  void add_pos_z(double pos_z) {
    fbb_.AddElement<double>(StateSnapshot::VT_POS_Z, pos_z, 0.0);
  }
  void add_vel_x(double vel_x) {
    fbb_.AddElement<double>(StateSnapshot::VT_VEL_X, vel_x, 0.0);
  }
  void add_vel_y(double vel_y) {
    fbb_.AddElement<double>(StateSnapshot::VT_VEL_Y, vel_y, 0.0);
  }
  void add_vel_z(double vel_z) {
    fbb_.AddElement<double>(StateSnapshot::VT_VEL_Z, vel_z, 0.0);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_ammo_in_mag(int32_t ammo_in_mag) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_AMMO_IN_MAG, ammo_in_mag, 0);
  }
  void add_dash_cooldown(double dash_cooldown) {
    fbb_.AddElement<double>(StateSnapshot::VT_DASH_COOLDOWN, dash_cooldown, 0.0);
  }
  void add_health(double health) {
    fbb_.AddElement<double>(StateSnapshot::VT_HEALTH, health, 0.0);
  }
  void add_kills(int32_t kills) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_KILLS, kills, 0);
  }
  void add_deaths(int32_t deaths) {
    fbb_.AddElement<int32_t>(StateSnapshot::VT_DEATHS, deaths, 0);
  }
  void add_view_yaw_q(int16_t view_yaw_q) {
    fbb_.AddElement<int16_t>(StateSnapshot::VT_VIEW_YAW_Q, view_yaw_q, 0);
  }
  void add_view_pitch_q(int16_t view_pitch_q) {
    fbb_.AddElement<int16_t>(StateSnapshot::VT_VIEW_PITCH_Q, view_pitch_q, 0);
  }
  void add_player_flags(uint8_t player_flags) {
    fbb_.AddElement<uint8_t>(StateSnapshot::VT_PLAYER_FLAGS, player_flags, 0);
  }
  void add_weapon_heat_q(uint16_t weapon_heat_q) {
    fbb_.AddElement<uint16_t>(StateSnapshot::VT_WEAPON_HEAT_Q, weapon_heat_q, 0);
  }
  void add_loadout_bits(uint32_t loadout_bits) {
    fbb_.AddElement<uint32_t>(StateSnapshot::VT_LOADOUT_BITS, loadout_bits, 0);
  }
  explicit StateSnapshotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateSnapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateSnapshot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateSnapshot> CreateStateSnapshot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    int32_t last_processed_input_seq = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    int32_t weapon_slot = 0,
    int32_t ammo_in_mag = 0,
    double dash_cooldown = 0.0,
    double health = 0.0,
    int32_t kills = 0,
    int32_t deaths = 0,
    int16_t view_yaw_q = 0,
    int16_t view_pitch_q = 0,
    uint8_t player_flags = 0,
    uint16_t weapon_heat_q = 0,
    uint32_t loadout_bits = 0) {
  StateSnapshotBuilder builder_(_fbb);
  builder_.add_health(health);
  builder_.add_dash_cooldown(dash_cooldown);
  builder_.add_vel_z(vel_z);
  builder_.add_vel_y(vel_y);
  builder_.add_vel_x(vel_x);
  builder_.add_pos_z(pos_z);
  builder_.add_pos_y(pos_y);
  builder_.add_pos_x(pos_x);
  builder_.add_loadout_bits(loadout_bits);
  builder_.add_deaths(deaths);
  builder_.add_kills(kills);
  builder_.add_ammo_in_mag(ammo_in_mag);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_client_id(client_id);
  builder_.add_last_processed_input_seq(last_processed_input_seq);
  builder_.add_server_tick(server_tick);
  builder_.add_weapon_heat_q(weapon_heat_q);
  builder_.add_view_pitch_q(view_pitch_q);
  builder_.add_view_yaw_q(view_yaw_q);
  builder_.add_player_flags(player_flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StateSnapshot> CreateStateSnapshotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    int32_t last_processed_input_seq = 0,
    const char *client_id = nullptr,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    int32_t weapon_slot = 0,
    int32_t ammo_in_mag = 0,
    double dash_cooldown = 0.0,
    double health = 0.0,
    int32_t kills = 0,
    int32_t deaths = 0,
    int16_t view_yaw_q = 0,
    int16_t view_pitch_q = 0,
    uint8_t player_flags = 0,
    uint16_t weapon_heat_q = 0,
    uint32_t loadout_bits = 0) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  return afps::protocol::CreateStateSnapshot(
      _fbb,
      server_tick,
      last_processed_input_seq,
      client_id__,
      pos_x,
      pos_y,
      pos_z,
      vel_x,
      vel_y,
      vel_z,
      weapon_slot,
      ammo_in_mag,
      dash_cooldown,
      health,
      kills,
      deaths,
      view_yaw_q,
      view_pitch_q,
      player_flags,
      weapon_heat_q,
      loadout_bits);
}

::flatbuffers::Offset<StateSnapshot> CreateStateSnapshot(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateSnapshotDeltaT : public ::flatbuffers::NativeTable {
  typedef StateSnapshotDelta TableType;
  int32_t server_tick = 0;
  int32_t base_tick = 0;
  int32_t last_processed_input_seq = 0;
  int32_t mask = 0;
  std::string client_id{};
  double pos_x = 0.0;
  double pos_y = 0.0;
  double pos_z = 0.0;
  double vel_x = 0.0;
  double vel_y = 0.0;
  double vel_z = 0.0;
  int32_t weapon_slot = 0;
  int32_t ammo_in_mag = 0;
  double dash_cooldown = 0.0;
  double health = 0.0;
  int32_t kills = 0;
  int32_t deaths = 0;
  int16_t view_yaw_q = 0;
  int16_t view_pitch_q = 0;
  uint8_t player_flags = 0;
  uint16_t weapon_heat_q = 0;
  uint32_t loadout_bits = 0;
};

struct StateSnapshotDelta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateSnapshotDeltaT NativeTableType;
  typedef StateSnapshotDeltaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_TICK = 4,
    VT_BASE_TICK = 6,
    VT_LAST_PROCESSED_INPUT_SEQ = 8,
    VT_MASK = 10,
    VT_CLIENT_ID = 12,
    VT_POS_X = 14,
    VT_POS_Y = 16,
    VT_POS_Z = 18,
    VT_VEL_X = 20,
    VT_VEL_Y = 22,
    VT_VEL_Z = 24,
    VT_WEAPON_SLOT = 26,
    VT_AMMO_IN_MAG = 28,
    VT_DASH_COOLDOWN = 30,
    VT_HEALTH = 32,
    VT_KILLS = 34,
    VT_DEATHS = 36,
    VT_VIEW_YAW_Q = 38,
    VT_VIEW_PITCH_Q = 40,
    VT_PLAYER_FLAGS = 42,
    VT_WEAPON_HEAT_Q = 44,
    VT_LOADOUT_BITS = 46
  };
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  int32_t base_tick() const {
    return GetField<int32_t>(VT_BASE_TICK, 0);
  }
  int32_t last_processed_input_seq() const {
    return GetField<int32_t>(VT_LAST_PROCESSED_INPUT_SEQ, 0);
  }
  int32_t mask() const {
    return GetField<int32_t>(VT_MASK, 0);
  }
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  double pos_x() const {
    return GetField<double>(VT_POS_X, 0.0);
  }
  double pos_y() const {
    return GetField<double>(VT_POS_Y, 0.0);
  }
  double pos_z() const {
    return GetField<double>(VT_POS_Z, 0.0);
  }
  double vel_x() const {
    return GetField<double>(VT_VEL_X, 0.0);
  }
  double vel_y() const {
    return GetField<double>(VT_VEL_Y, 0.0);
  }
  double vel_z() const {
    return GetField<double>(VT_VEL_Z, 0.0);
  }
  int32_t weapon_slot() const {
    return GetField<int32_t>(VT_WEAPON_SLOT, 0);
  }
  int32_t ammo_in_mag() const {
    return GetField<int32_t>(VT_AMMO_IN_MAG, 0);
  }
  double dash_cooldown() const {
    return GetField<double>(VT_DASH_COOLDOWN, 0.0);
  }
  double health() const {
    return GetField<double>(VT_HEALTH, 0.0);
  }
  int32_t kills() const {
    return GetField<int32_t>(VT_KILLS, 0);
  }
  int32_t deaths() const {
    return GetField<int32_t>(VT_DEATHS, 0);
  }
  int16_t view_yaw_q() const {
    return GetField<int16_t>(VT_VIEW_YAW_Q, 0);
  }
  int16_t view_pitch_q() const {
    return GetField<int16_t>(VT_VIEW_PITCH_Q, 0);
  }
  uint8_t player_flags() const {
    return GetField<uint8_t>(VT_PLAYER_FLAGS, 0);
  }
  uint16_t weapon_heat_q() const {
    return GetField<uint16_t>(VT_WEAPON_HEAT_Q, 0);
  }
  uint32_t loadout_bits() const {
    return GetField<uint32_t>(VT_LOADOUT_BITS, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           VerifyField<int32_t>(verifier, VT_BASE_TICK, 4) &&
           VerifyField<int32_t>(verifier, VT_LAST_PROCESSED_INPUT_SEQ, 4) &&
           VerifyField<int32_t>(verifier, VT_MASK, 4) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyField<double>(verifier, VT_POS_X, 8) &&
           VerifyField<double>(verifier, VT_POS_Y, 8) &&
           VerifyField<double>(verifier, VT_POS_Z, 8) &&
           VerifyField<double>(verifier, VT_VEL_X, 8) &&
           VerifyField<double>(verifier, VT_VEL_Y, 8) &&
           VerifyField<double>(verifier, VT_VEL_Z, 8) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_SLOT, 4) &&
           VerifyField<int32_t>(verifier, VT_AMMO_IN_MAG, 4) &&
           VerifyField<double>(verifier, VT_DASH_COOLDOWN, 8) &&
           VerifyField<double>(verifier, VT_HEALTH, 8) &&
           VerifyField<int32_t>(verifier, VT_KILLS, 4) &&
           VerifyField<int32_t>(verifier, VT_DEATHS, 4) &&
           VerifyField<int16_t>(verifier, VT_VIEW_YAW_Q, 2) &&
           VerifyField<int16_t>(verifier, VT_VIEW_PITCH_Q, 2) &&
           VerifyField<uint8_t>(verifier, VT_PLAYER_FLAGS, 1) &&
           VerifyField<uint16_t>(verifier, VT_WEAPON_HEAT_Q, 2) &&
           VerifyField<uint32_t>(verifier, VT_LOADOUT_BITS, 4) &&
           verifier.EndTable();
  }
  StateSnapshotDeltaT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateSnapshotDeltaT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StateSnapshotDelta> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotDeltaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateSnapshotDeltaBuilder {
  typedef StateSnapshotDelta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_SERVER_TICK, server_tick, 0);
  }
  void add_base_tick(int32_t base_tick) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_BASE_TICK, base_tick, 0);
  }
  void add_last_processed_input_seq(int32_t last_processed_input_seq) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_LAST_PROCESSED_INPUT_SEQ, last_processed_input_seq, 0);
  }
  void add_mask(int32_t mask) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_MASK, mask, 0);
  }
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(StateSnapshotDelta::VT_CLIENT_ID, client_id);
  }
  void add_pos_x(double pos_x) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_POS_X, pos_x, 0.0);
  }
  void add_pos_y(double pos_y) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_POS_Y, pos_y, 0.0);
  }
  void add_pos_z(double pos_z) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_POS_Z, pos_z, 0.0);
  }
  void add_vel_x(double vel_x) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_VEL_X, vel_x, 0.0);
  }
  void add_vel_y(double vel_y) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_VEL_Y, vel_y, 0.0);
  }
  void add_vel_z(double vel_z) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_VEL_Z, vel_z, 0.0);
  }
  void add_weapon_slot(int32_t weapon_slot) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_WEAPON_SLOT, weapon_slot, 0);
  }
  void add_ammo_in_mag(int32_t ammo_in_mag) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_AMMO_IN_MAG, ammo_in_mag, 0);
  }
  void add_dash_cooldown(double dash_cooldown) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_DASH_COOLDOWN, dash_cooldown, 0.0);
  }
  void add_health(double health) {
    fbb_.AddElement<double>(StateSnapshotDelta::VT_HEALTH, health, 0.0);
  }
  void add_kills(int32_t kills) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_KILLS, kills, 0);
  }
  void add_deaths(int32_t deaths) {
    fbb_.AddElement<int32_t>(StateSnapshotDelta::VT_DEATHS, deaths, 0);
  }
  void add_view_yaw_q(int16_t view_yaw_q) {
    fbb_.AddElement<int16_t>(StateSnapshotDelta::VT_VIEW_YAW_Q, view_yaw_q, 0);
  }
  void add_view_pitch_q(int16_t view_pitch_q) {
    fbb_.AddElement<int16_t>(StateSnapshotDelta::VT_VIEW_PITCH_Q, view_pitch_q, 0);
  }
  void add_player_flags(uint8_t player_flags) {
    fbb_.AddElement<uint8_t>(StateSnapshotDelta::VT_PLAYER_FLAGS, player_flags, 0);
  }
  void add_weapon_heat_q(uint16_t weapon_heat_q) {
    fbb_.AddElement<uint16_t>(StateSnapshotDelta::VT_WEAPON_HEAT_Q, weapon_heat_q, 0);
  }
  void add_loadout_bits(uint32_t loadout_bits) {
    fbb_.AddElement<uint32_t>(StateSnapshotDelta::VT_LOADOUT_BITS, loadout_bits, 0);
  }
  explicit StateSnapshotDeltaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateSnapshotDelta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateSnapshotDelta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateSnapshotDelta> CreateStateSnapshotDelta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    int32_t base_tick = 0,
    int32_t last_processed_input_seq = 0,
    int32_t mask = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    int32_t weapon_slot = 0,
    int32_t ammo_in_mag = 0,
    double dash_cooldown = 0.0,
    double health = 0.0,
    int32_t kills = 0,
    int32_t deaths = 0,
    int16_t view_yaw_q = 0,
    int16_t view_pitch_q = 0,
    uint8_t player_flags = 0,
    uint16_t weapon_heat_q = 0,
    uint32_t loadout_bits = 0) {
  StateSnapshotDeltaBuilder builder_(_fbb);
  builder_.add_health(health);
  builder_.add_dash_cooldown(dash_cooldown);
  builder_.add_vel_z(vel_z);
  builder_.add_vel_y(vel_y);
  builder_.add_vel_x(vel_x);
  builder_.add_pos_z(pos_z);
  builder_.add_pos_y(pos_y);
  builder_.add_pos_x(pos_x);
  builder_.add_loadout_bits(loadout_bits);
  builder_.add_deaths(deaths);
  builder_.add_kills(kills);
  builder_.add_ammo_in_mag(ammo_in_mag);
  builder_.add_weapon_slot(weapon_slot);
  builder_.add_client_id(client_id);
  builder_.add_mask(mask);
  builder_.add_last_processed_input_seq(last_processed_input_seq);
  builder_.add_base_tick(base_tick);
  builder_.add_server_tick(server_tick);
  builder_.add_weapon_heat_q(weapon_heat_q);
  builder_.add_view_pitch_q(view_pitch_q);
  builder_.add_view_yaw_q(view_yaw_q);
  builder_.add_player_flags(player_flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StateSnapshotDelta> CreateStateSnapshotDeltaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    int32_t base_tick = 0,
    int32_t last_processed_input_seq = 0,
    int32_t mask = 0,
    const char *client_id = nullptr,
    double pos_x = 0.0,
    double pos_y = 0.0,
    double pos_z = 0.0,
    double vel_x = 0.0,
    double vel_y = 0.0,
    double vel_z = 0.0,
    int32_t weapon_slot = 0,
    int32_t ammo_in_mag = 0,
    double dash_cooldown = 0.0,
    double health = 0.0,
    int32_t kills = 0,
    int32_t deaths = 0,
    int16_t view_yaw_q = 0,
    int16_t view_pitch_q = 0,
    uint8_t player_flags = 0,
    uint16_t weapon_heat_q = 0,
    uint32_t loadout_bits = 0) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  return afps::protocol::CreateStateSnapshotDelta(
      _fbb,
      server_tick,
      base_tick,
      last_processed_input_seq,
      mask,
      client_id__,
      pos_x,
      pos_y,
      pos_z,
      vel_x,
      vel_y,
      vel_z,
      weapon_slot,
      ammo_in_mag,
      dash_cooldown,
      health,
      kills,
      deaths,
      view_yaw_q,
      view_pitch_q,
      player_flags,
      weapon_heat_q,
      loadout_bits);
}

::flatbuffers::Offset<StateSnapshotDelta> CreateStateSnapshotDelta(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotDeltaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerProfileT : public ::flatbuffers::NativeTable {
  typedef PlayerProfile TableType;
  std::string client_id{};
  std::string nickname{};
  std::string character_id{};
};

struct PlayerProfile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerProfileT NativeTableType;
  typedef PlayerProfileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ID = 4,
    VT_NICKNAME = 6,
    VT_CHARACTER_ID = 8
  };
  const ::flatbuffers::String *client_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ID);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  const ::flatbuffers::String *character_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARACTER_ID);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           VerifyOffset(verifier, VT_CHARACTER_ID) &&
           verifier.VerifyString(character_id()) &&
           verifier.EndTable();
  }
  PlayerProfileT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerProfileT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlayerProfile> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerProfileT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerProfileBuilder {
  typedef PlayerProfile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_id(::flatbuffers::Offset<::flatbuffers::String> client_id) {
    fbb_.AddOffset(PlayerProfile::VT_CLIENT_ID, client_id);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(PlayerProfile::VT_NICKNAME, nickname);
  }
  void add_character_id(::flatbuffers::Offset<::flatbuffers::String> character_id) {
    fbb_.AddOffset(PlayerProfile::VT_CHARACTER_ID, character_id);
  }
  explicit PlayerProfileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerProfile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerProfile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerProfile> CreatePlayerProfile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> client_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> character_id = 0) {
  PlayerProfileBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  builder_.add_nickname(nickname);
  builder_.add_client_id(client_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerProfile> CreatePlayerProfileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *client_id = nullptr,
    const char *nickname = nullptr,
    const char *character_id = nullptr) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  auto character_id__ = character_id ? _fbb.CreateString(character_id) : 0;
  return afps::protocol::CreatePlayerProfile(
      _fbb,
      client_id__,
      nickname__,
      character_id__);
}

::flatbuffers::Offset<PlayerProfile> CreatePlayerProfile(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerProfileT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GameEventT : public ::flatbuffers::NativeTable {
  typedef GameEvent TableType;
  int32_t server_tick = 0;
  std::vector<afps::protocol::FxEventUnion> events{};
};

struct GameEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameEventT NativeTableType;
  typedef GameEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_TICK = 4,
    VT_EVENTS_TYPE = 6,
    VT_EVENTS = 8
  };
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  const ::flatbuffers::Vector<afps::protocol::FxEvent> *events_type() const {
    return GetPointer<const ::flatbuffers::Vector<afps::protocol::FxEvent> *>(VT_EVENTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *events() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_EVENTS);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           VerifyOffset(verifier, VT_EVENTS_TYPE) &&
           verifier.VerifyVector(events_type()) &&
           VerifyOffset(verifier, VT_EVENTS) &&
           verifier.VerifyVector(events()) &&
           VerifyFxEventVector(verifier, events(), events_type()) &&
           verifier.EndTable();
  }
  GameEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GameEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GameEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GameEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GameEventBuilder {
  typedef GameEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(GameEvent::VT_SERVER_TICK, server_tick, 0);
  }
  void add_events_type(::flatbuffers::Offset<::flatbuffers::Vector<afps::protocol::FxEvent>> events_type) {
    fbb_.AddOffset(GameEvent::VT_EVENTS_TYPE, events_type);
  }
  void add_events(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> events) {
    fbb_.AddOffset(GameEvent::VT_EVENTS, events);
  }
  explicit GameEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameEvent> CreateGameEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<afps::protocol::FxEvent>> events_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> events = 0) {
  GameEventBuilder builder_(_fbb);
  builder_.add_events(events);
  builder_.add_events_type(events_type);
  builder_.add_server_tick(server_tick);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GameEvent> CreateGameEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_tick = 0,
    const std::vector<afps::protocol::FxEvent> *events_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *events = nullptr) {
  auto events_type__ = events_type ? _fbb.CreateVector<afps::protocol::FxEvent>(*events_type) : 0;
  auto events__ = events ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*events) : 0;
  return afps::protocol::CreateGameEvent(
      _fbb,
      server_tick,
      events_type__,
      events__);
}

::flatbuffers::Offset<GameEvent> CreateGameEvent(::flatbuffers::FlatBufferBuilder &_fbb, const GameEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PingT : public ::flatbuffers::NativeTable {
  typedef Ping TableType;
  double client_time_ms = 0.0;
};

struct Ping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PingT NativeTableType;
  typedef PingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_TIME_MS = 4
  };
  double client_time_ms() const {
    return GetField<double>(VT_CLIENT_TIME_MS, 0.0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_CLIENT_TIME_MS, 8) &&
           verifier.EndTable();
  }
  PingT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PingT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Ping> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PingBuilder {
  typedef Ping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_time_ms(double client_time_ms) {
    fbb_.AddElement<double>(Ping::VT_CLIENT_TIME_MS, client_time_ms, 0.0);
  }
  explicit PingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ping> CreatePing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double client_time_ms = 0.0) {
  PingBuilder builder_(_fbb);
  builder_.add_client_time_ms(client_time_ms);
  return builder_.Finish();
}

::flatbuffers::Offset<Ping> CreatePing(::flatbuffers::FlatBufferBuilder &_fbb, const PingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PongT : public ::flatbuffers::NativeTable {
  typedef Pong TableType;
  double client_time_ms = 0.0;
};

struct Pong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PongT NativeTableType;
  typedef PongBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_TIME_MS = 4
  };
  double client_time_ms() const {
    return GetField<double>(VT_CLIENT_TIME_MS, 0.0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_CLIENT_TIME_MS, 8) &&
           verifier.EndTable();
  }
  PongT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PongT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pong> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PongT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PongBuilder {
  typedef Pong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_time_ms(double client_time_ms) {
    fbb_.AddElement<double>(Pong::VT_CLIENT_TIME_MS, client_time_ms, 0.0);
  }
  explicit PongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pong> CreatePong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double client_time_ms = 0.0) {
  PongBuilder builder_(_fbb);
  builder_.add_client_time_ms(client_time_ms);
  return builder_.Finish();
}

::flatbuffers::Offset<Pong> CreatePong(::flatbuffers::FlatBufferBuilder &_fbb, const PongT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public ::flatbuffers::NativeTable {
  typedef Error TableType;
  std::string code{};
  std::string message{};
};

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorT NativeTableType;
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6
  };
  const ::flatbuffers::String *code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CODE);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Error> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(::flatbuffers::Offset<::flatbuffers::String> code) {
    fbb_.AddOffset(Error::VT_CODE, code);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const char *message = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return afps::protocol::CreateError(
      _fbb,
      code__,
      message__);
}

::flatbuffers::Offset<Error> CreateError(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DisconnectT : public ::flatbuffers::NativeTable {
  typedef Disconnect TableType;
  std::string code{};
  std::string message{};
};

struct Disconnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DisconnectT NativeTableType;
  typedef DisconnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6
  };
  const ::flatbuffers::String *code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CODE);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  DisconnectT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DisconnectT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Disconnect> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DisconnectT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DisconnectBuilder {
  typedef Disconnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(::flatbuffers::Offset<::flatbuffers::String> code) {
    fbb_.AddOffset(Disconnect::VT_CODE, code);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Disconnect::VT_MESSAGE, message);
  }
  explicit DisconnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Disconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Disconnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Disconnect> CreateDisconnect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  DisconnectBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Disconnect> CreateDisconnectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const char *message = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return afps::protocol::CreateDisconnect(
      _fbb,
      code__,
      message__);
}

::flatbuffers::Offset<Disconnect> CreateDisconnect(::flatbuffers::FlatBufferBuilder &_fbb, const DisconnectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ShotFiredFxT *ShotFiredFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ShotFiredFxT>(new ShotFiredFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ShotFiredFx::UnPackTo(ShotFiredFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = shot_seq(); _o->shot_seq = _e; }
  { auto _e = dry_fire(); _o->dry_fire = _e; }
}

inline ::flatbuffers::Offset<ShotFiredFx> CreateShotFiredFx(::flatbuffers::FlatBufferBuilder &_fbb, const ShotFiredFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ShotFiredFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ShotFiredFx> ShotFiredFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ShotFiredFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ShotFiredFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _weapon_slot = _o->weapon_slot;
  auto _shot_seq = _o->shot_seq;
  auto _dry_fire = _o->dry_fire;
  return afps::protocol::CreateShotFiredFx(
      _fbb,
      _shooter_id,
      _weapon_slot,
      _shot_seq,
      _dry_fire);
}

inline ShotTraceFxT *ShotTraceFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ShotTraceFxT>(new ShotTraceFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ShotTraceFx::UnPackTo(ShotTraceFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = shot_seq(); _o->shot_seq = _e; }
  { auto _e = dir_oct_x(); _o->dir_oct_x = _e; }
  { auto _e = dir_oct_y(); _o->dir_oct_y = _e; }
  { auto _e = hit_dist_q(); _o->hit_dist_q = _e; }
  { auto _e = hit_kind(); _o->hit_kind = _e; }
  { auto _e = surface_type(); _o->surface_type = _e; }
  { auto _e = normal_oct_x(); _o->normal_oct_x = _e; }
  { auto _e = normal_oct_y(); _o->normal_oct_y = _e; }
  { auto _e = show_tracer(); _o->show_tracer = _e; }
  { auto _e = hit_pos_x_q(); _o->hit_pos_x_q = _e; }
  { auto _e = hit_pos_y_q(); _o->hit_pos_y_q = _e; }
  { auto _e = hit_pos_z_q(); _o->hit_pos_z_q = _e; }
}

inline ::flatbuffers::Offset<ShotTraceFx> CreateShotTraceFx(::flatbuffers::FlatBufferBuilder &_fbb, const ShotTraceFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ShotTraceFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ShotTraceFx> ShotTraceFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ShotTraceFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ShotTraceFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _weapon_slot = _o->weapon_slot;
  auto _shot_seq = _o->shot_seq;
  auto _dir_oct_x = _o->dir_oct_x;
  auto _dir_oct_y = _o->dir_oct_y;
  auto _hit_dist_q = _o->hit_dist_q;
  auto _hit_kind = _o->hit_kind;
  auto _surface_type = _o->surface_type;
  auto _normal_oct_x = _o->normal_oct_x;
  auto _normal_oct_y = _o->normal_oct_y;
  auto _show_tracer = _o->show_tracer;
  auto _hit_pos_x_q = _o->hit_pos_x_q;
  auto _hit_pos_y_q = _o->hit_pos_y_q;
  auto _hit_pos_z_q = _o->hit_pos_z_q;
  return afps::protocol::CreateShotTraceFx(
      _fbb,
      _shooter_id,
      _weapon_slot,
      _shot_seq,
      _dir_oct_x,
      _dir_oct_y,
      _hit_dist_q,
      _hit_kind,
      _surface_type,
      _normal_oct_x,
      _normal_oct_y,
      _show_tracer,
      _hit_pos_x_q,
      _hit_pos_y_q,
      _hit_pos_z_q);
}

inline ReloadFxT *ReloadFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReloadFxT>(new ReloadFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReloadFx::UnPackTo(ReloadFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
}

inline ::flatbuffers::Offset<ReloadFx> CreateReloadFx(::flatbuffers::FlatBufferBuilder &_fbb, const ReloadFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ReloadFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReloadFx> ReloadFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReloadFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReloadFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _weapon_slot = _o->weapon_slot;
  return afps::protocol::CreateReloadFx(
      _fbb,
      _shooter_id,
      _weapon_slot);
}

inline NearMissFxT *NearMissFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NearMissFxT>(new NearMissFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NearMissFx::UnPackTo(NearMissFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = shot_seq(); _o->shot_seq = _e; }
  { auto _e = strength(); _o->strength = _e; }
}

inline ::flatbuffers::Offset<NearMissFx> CreateNearMissFx(::flatbuffers::FlatBufferBuilder &_fbb, const NearMissFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return NearMissFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NearMissFx> NearMissFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NearMissFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NearMissFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _shot_seq = _o->shot_seq;
  auto _strength = _o->strength;
  return afps::protocol::CreateNearMissFx(
      _fbb,
      _shooter_id,
      _shot_seq,
      _strength);
}

inline OverheatFxT *OverheatFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OverheatFxT>(new OverheatFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OverheatFx::UnPackTo(OverheatFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = heat_q(); _o->heat_q = _e; }
}

inline ::flatbuffers::Offset<OverheatFx> CreateOverheatFx(::flatbuffers::FlatBufferBuilder &_fbb, const OverheatFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return OverheatFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OverheatFx> OverheatFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OverheatFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OverheatFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _weapon_slot = _o->weapon_slot;
  auto _heat_q = _o->heat_q;
  return afps::protocol::CreateOverheatFx(
      _fbb,
      _shooter_id,
      _weapon_slot,
      _heat_q);
}

inline VentFxT *VentFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VentFxT>(new VentFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VentFx::UnPackTo(VentFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
}

inline ::flatbuffers::Offset<VentFx> CreateVentFx(::flatbuffers::FlatBufferBuilder &_fbb, const VentFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return VentFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VentFx> VentFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VentFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VentFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _weapon_slot = _o->weapon_slot;
  return afps::protocol::CreateVentFx(
      _fbb,
      _shooter_id,
      _weapon_slot);
}

inline HitConfirmedFxT *HitConfirmedFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HitConfirmedFxT>(new HitConfirmedFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HitConfirmedFx::UnPackTo(HitConfirmedFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_id(); if (_e) _o->target_id = _e->str(); }
  { auto _e = damage(); _o->damage = _e; }
  { auto _e = killed(); _o->killed = _e; }
}

inline ::flatbuffers::Offset<HitConfirmedFx> CreateHitConfirmedFx(::flatbuffers::FlatBufferBuilder &_fbb, const HitConfirmedFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return HitConfirmedFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HitConfirmedFx> HitConfirmedFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HitConfirmedFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HitConfirmedFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_id = _o->target_id.empty() ? 0 : _fbb.CreateString(_o->target_id);
  auto _damage = _o->damage;
  auto _killed = _o->killed;
  return afps::protocol::CreateHitConfirmedFx(
      _fbb,
      _target_id,
      _damage,
      _killed);
}

inline KillFeedFxT *KillFeedFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<KillFeedFxT>(new KillFeedFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void KillFeedFx::UnPackTo(KillFeedFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = killer_id(); if (_e) _o->killer_id = _e->str(); }
  { auto _e = victim_id(); if (_e) _o->victim_id = _e->str(); }
}

inline ::flatbuffers::Offset<KillFeedFx> CreateKillFeedFx(::flatbuffers::FlatBufferBuilder &_fbb, const KillFeedFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return KillFeedFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<KillFeedFx> KillFeedFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KillFeedFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const KillFeedFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _killer_id = _o->killer_id.empty() ? 0 : _fbb.CreateString(_o->killer_id);
  auto _victim_id = _o->victim_id.empty() ? 0 : _fbb.CreateString(_o->victim_id);
  return afps::protocol::CreateKillFeedFx(
      _fbb,
      _killer_id,
      _victim_id);
}

inline ProjectileSpawnFxT *ProjectileSpawnFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProjectileSpawnFxT>(new ProjectileSpawnFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProjectileSpawnFx::UnPackTo(ProjectileSpawnFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shooter_id(); if (_e) _o->shooter_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = shot_seq(); _o->shot_seq = _e; }
  { auto _e = projectile_id(); _o->projectile_id = _e; }
  { auto _e = pos_x_q(); _o->pos_x_q = _e; }
  { auto _e = pos_y_q(); _o->pos_y_q = _e; }
  { auto _e = pos_z_q(); _o->pos_z_q = _e; }
  { auto _e = vel_x_q(); _o->vel_x_q = _e; }
  { auto _e = vel_y_q(); _o->vel_y_q = _e; }
  { auto _e = vel_z_q(); _o->vel_z_q = _e; }
  { auto _e = ttl_q(); _o->ttl_q = _e; }
}

inline ::flatbuffers::Offset<ProjectileSpawnFx> CreateProjectileSpawnFx(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileSpawnFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ProjectileSpawnFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ProjectileSpawnFx> ProjectileSpawnFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileSpawnFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ProjectileSpawnFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shooter_id = _o->shooter_id.empty() ? 0 : _fbb.CreateString(_o->shooter_id);
  auto _weapon_slot = _o->weapon_slot;
  auto _shot_seq = _o->shot_seq;
  auto _projectile_id = _o->projectile_id;
  auto _pos_x_q = _o->pos_x_q;
  auto _pos_y_q = _o->pos_y_q;
  auto _pos_z_q = _o->pos_z_q;
  auto _vel_x_q = _o->vel_x_q;
  auto _vel_y_q = _o->vel_y_q;
  auto _vel_z_q = _o->vel_z_q;
  auto _ttl_q = _o->ttl_q;
  return afps::protocol::CreateProjectileSpawnFx(
      _fbb,
      _shooter_id,
      _weapon_slot,
      _shot_seq,
      _projectile_id,
      _pos_x_q,
      _pos_y_q,
      _pos_z_q,
      _vel_x_q,
      _vel_y_q,
      _vel_z_q,
      _ttl_q);
}

inline ProjectileImpactFxT *ProjectileImpactFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProjectileImpactFxT>(new ProjectileImpactFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProjectileImpactFx::UnPackTo(ProjectileImpactFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = projectile_id(); _o->projectile_id = _e; }
  { auto _e = hit_world(); _o->hit_world = _e; }
  { auto _e = target_id(); if (_e) _o->target_id = _e->str(); }
  { auto _e = pos_x_q(); _o->pos_x_q = _e; }
  { auto _e = pos_y_q(); _o->pos_y_q = _e; }
  { auto _e = pos_z_q(); _o->pos_z_q = _e; }
  { auto _e = normal_oct_x(); _o->normal_oct_x = _e; }
  { auto _e = normal_oct_y(); _o->normal_oct_y = _e; }
  { auto _e = surface_type(); _o->surface_type = _e; }
}

inline ::flatbuffers::Offset<ProjectileImpactFx> CreateProjectileImpactFx(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileImpactFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ProjectileImpactFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ProjectileImpactFx> ProjectileImpactFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileImpactFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ProjectileImpactFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _projectile_id = _o->projectile_id;
  auto _hit_world = _o->hit_world;
  auto _target_id = _o->target_id.empty() ? 0 : _fbb.CreateString(_o->target_id);
  auto _pos_x_q = _o->pos_x_q;
  auto _pos_y_q = _o->pos_y_q;
  auto _pos_z_q = _o->pos_z_q;
  auto _normal_oct_x = _o->normal_oct_x;
  auto _normal_oct_y = _o->normal_oct_y;
  auto _surface_type = _o->surface_type;
  return afps::protocol::CreateProjectileImpactFx(
      _fbb,
      _projectile_id,
      _hit_world,
      _target_id,
      _pos_x_q,
      _pos_y_q,
      _pos_z_q,
      _normal_oct_x,
      _normal_oct_y,
      _surface_type);
}

inline ProjectileRemoveFxT *ProjectileRemoveFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProjectileRemoveFxT>(new ProjectileRemoveFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProjectileRemoveFx::UnPackTo(ProjectileRemoveFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = projectile_id(); _o->projectile_id = _e; }
}

inline ::flatbuffers::Offset<ProjectileRemoveFx> CreateProjectileRemoveFx(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileRemoveFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ProjectileRemoveFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ProjectileRemoveFx> ProjectileRemoveFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ProjectileRemoveFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ProjectileRemoveFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _projectile_id = _o->projectile_id;
  return afps::protocol::CreateProjectileRemoveFx(
      _fbb,
      _projectile_id);
}

inline PickupSpawnedFxT *PickupSpawnedFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PickupSpawnedFxT>(new PickupSpawnedFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PickupSpawnedFx::UnPackTo(PickupSpawnedFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pickup_id(); _o->pickup_id = _e; }
  { auto _e = kind(); _o->kind = _e; }
  { auto _e = pos_x_q(); _o->pos_x_q = _e; }
  { auto _e = pos_y_q(); _o->pos_y_q = _e; }
  { auto _e = pos_z_q(); _o->pos_z_q = _e; }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = amount(); _o->amount = _e; }
}

inline ::flatbuffers::Offset<PickupSpawnedFx> CreatePickupSpawnedFx(::flatbuffers::FlatBufferBuilder &_fbb, const PickupSpawnedFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return PickupSpawnedFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PickupSpawnedFx> PickupSpawnedFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PickupSpawnedFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PickupSpawnedFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pickup_id = _o->pickup_id;
  auto _kind = _o->kind;
  auto _pos_x_q = _o->pos_x_q;
  auto _pos_y_q = _o->pos_y_q;
  auto _pos_z_q = _o->pos_z_q;
  auto _weapon_slot = _o->weapon_slot;
  auto _amount = _o->amount;
  return afps::protocol::CreatePickupSpawnedFx(
      _fbb,
      _pickup_id,
      _kind,
      _pos_x_q,
      _pos_y_q,
      _pos_z_q,
      _weapon_slot,
      _amount);
}

inline PickupTakenFxT *PickupTakenFx::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PickupTakenFxT>(new PickupTakenFxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PickupTakenFx::UnPackTo(PickupTakenFxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pickup_id(); _o->pickup_id = _e; }
  { auto _e = taker_id(); if (_e) _o->taker_id = _e->str(); }
  { auto _e = server_tick(); _o->server_tick = _e; }
}

inline ::flatbuffers::Offset<PickupTakenFx> CreatePickupTakenFx(::flatbuffers::FlatBufferBuilder &_fbb, const PickupTakenFxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return PickupTakenFx::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PickupTakenFx> PickupTakenFx::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PickupTakenFxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PickupTakenFxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pickup_id = _o->pickup_id;
  auto _taker_id = _o->taker_id.empty() ? 0 : _fbb.CreateString(_o->taker_id);
  auto _server_tick = _o->server_tick;
  return afps::protocol::CreatePickupTakenFx(
      _fbb,
      _pickup_id,
      _taker_id,
      _server_tick);
}

inline ClientHelloT *ClientHello::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ClientHelloT>(new ClientHelloT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ClientHello::UnPackTo(ClientHelloT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = protocol_version(); _o->protocol_version = _e; }
  { auto _e = session_token(); if (_e) _o->session_token = _e->str(); }
  { auto _e = connection_id(); if (_e) _o->connection_id = _e->str(); }
  { auto _e = build(); if (_e) _o->build = _e->str(); }
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
  { auto _e = character_id(); if (_e) _o->character_id = _e->str(); }
}

inline ::flatbuffers::Offset<ClientHello> CreateClientHello(::flatbuffers::FlatBufferBuilder &_fbb, const ClientHelloT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ClientHello::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ClientHello> ClientHello::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ClientHelloT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ClientHelloT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _protocol_version = _o->protocol_version;
  auto _session_token = _o->session_token.empty() ? 0 : _fbb.CreateString(_o->session_token);
  auto _connection_id = _o->connection_id.empty() ? 0 : _fbb.CreateString(_o->connection_id);
  auto _build = _o->build.empty() ? 0 : _fbb.CreateString(_o->build);
  auto _nickname = _o->nickname.empty() ? 0 : _fbb.CreateString(_o->nickname);
  auto _character_id = _o->character_id.empty() ? 0 : _fbb.CreateString(_o->character_id);
  return afps::protocol::CreateClientHello(
      _fbb,
      _protocol_version,
      _session_token,
      _connection_id,
      _build,
      _nickname,
      _character_id);
}

inline ServerHelloT *ServerHello::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ServerHelloT>(new ServerHelloT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ServerHello::UnPackTo(ServerHelloT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = protocol_version(); _o->protocol_version = _e; }
  { auto _e = connection_id(); if (_e) _o->connection_id = _e->str(); }
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = server_tick_rate(); _o->server_tick_rate = _e; }
  { auto _e = snapshot_rate(); _o->snapshot_rate = _e; }
  { auto _e = snapshot_keyframe_interval(); _o->snapshot_keyframe_interval = _e; }
  { auto _e = motd(); if (_e) _o->motd = _e->str(); }
  { auto _e = connection_nonce(); if (_e) _o->connection_nonce = _e->str(); }
  { auto _e = map_seed(); _o->map_seed = _e; }
}

inline ::flatbuffers::Offset<ServerHello> CreateServerHello(::flatbuffers::FlatBufferBuilder &_fbb, const ServerHelloT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ServerHello::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ServerHello> ServerHello::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ServerHelloT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ServerHelloT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _protocol_version = _o->protocol_version;
  auto _connection_id = _o->connection_id.empty() ? 0 : _fbb.CreateString(_o->connection_id);
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _server_tick_rate = _o->server_tick_rate;
  auto _snapshot_rate = _o->snapshot_rate;
  auto _snapshot_keyframe_interval = _o->snapshot_keyframe_interval;
  auto _motd = _o->motd.empty() ? 0 : _fbb.CreateString(_o->motd);
  auto _connection_nonce = _o->connection_nonce.empty() ? 0 : _fbb.CreateString(_o->connection_nonce);
  auto _map_seed = _o->map_seed;
  return afps::protocol::CreateServerHello(
      _fbb,
      _protocol_version,
      _connection_id,
      _client_id,
      _server_tick_rate,
      _snapshot_rate,
      _snapshot_keyframe_interval,
      _motd,
      _connection_nonce,
      _map_seed);
}

inline JoinRequestT *JoinRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JoinRequestT>(new JoinRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JoinRequest::UnPackTo(JoinRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
  { auto _e = character_id(); if (_e) _o->character_id = _e->str(); }
}

inline ::flatbuffers::Offset<JoinRequest> CreateJoinRequest(::flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return JoinRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<JoinRequest> JoinRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JoinRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nickname = _o->nickname.empty() ? 0 : _fbb.CreateString(_o->nickname);
  auto _character_id = _o->character_id.empty() ? 0 : _fbb.CreateString(_o->character_id);
  return afps::protocol::CreateJoinRequest(
      _fbb,
      _nickname,
      _character_id);
}

inline JoinAcceptT *JoinAccept::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JoinAcceptT>(new JoinAcceptT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JoinAccept::UnPackTo(JoinAcceptT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
}

inline ::flatbuffers::Offset<JoinAccept> CreateJoinAccept(::flatbuffers::FlatBufferBuilder &_fbb, const JoinAcceptT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return JoinAccept::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<JoinAccept> JoinAccept::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoinAcceptT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JoinAcceptT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  return afps::protocol::CreateJoinAccept(
      _fbb,
      _client_id);
}

inline InputCmdT *InputCmd::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputCmdT>(new InputCmdT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InputCmd::UnPackTo(InputCmdT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = input_seq(); _o->input_seq = _e; }
  { auto _e = move_x(); _o->move_x = _e; }
  { auto _e = move_y(); _o->move_y = _e; }
  { auto _e = look_delta_x(); _o->look_delta_x = _e; }
  { auto _e = look_delta_y(); _o->look_delta_y = _e; }
  { auto _e = view_yaw(); _o->view_yaw = _e; }
  { auto _e = view_pitch(); _o->view_pitch = _e; }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = jump(); _o->jump = _e; }
  { auto _e = fire(); _o->fire = _e; }
  { auto _e = ads(); _o->ads = _e; }
  { auto _e = sprint(); _o->sprint = _e; }
  { auto _e = dash(); _o->dash = _e; }
  { auto _e = grapple(); _o->grapple = _e; }
  { auto _e = shield(); _o->shield = _e; }
  { auto _e = shockwave(); _o->shockwave = _e; }
  { auto _e = crouch(); _o->crouch = _e; }
}

inline ::flatbuffers::Offset<InputCmd> CreateInputCmd(::flatbuffers::FlatBufferBuilder &_fbb, const InputCmdT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return InputCmd::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<InputCmd> InputCmd::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InputCmdT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InputCmdT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _input_seq = _o->input_seq;
  auto _move_x = _o->move_x;
  auto _move_y = _o->move_y;
  auto _look_delta_x = _o->look_delta_x;
  auto _look_delta_y = _o->look_delta_y;
  auto _view_yaw = _o->view_yaw;
  auto _view_pitch = _o->view_pitch;
  auto _weapon_slot = _o->weapon_slot;
  auto _jump = _o->jump;
  auto _fire = _o->fire;
  auto _ads = _o->ads;
  auto _sprint = _o->sprint;
  auto _dash = _o->dash;
  auto _grapple = _o->grapple;
  auto _shield = _o->shield;
  auto _shockwave = _o->shockwave;
  auto _crouch = _o->crouch;
  return afps::protocol::CreateInputCmd(
      _fbb,
      _input_seq,
      _move_x,
      _move_y,
      _look_delta_x,
      _look_delta_y,
      _view_yaw,
      _view_pitch,
      _weapon_slot,
      _jump,
      _fire,
      _ads,
      _sprint,
      _dash,
      _grapple,
      _shield,
      _shockwave,
      _crouch);
}

inline FireWeaponRequestT *FireWeaponRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FireWeaponRequestT>(new FireWeaponRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FireWeaponRequest::UnPackTo(FireWeaponRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_shot_seq(); _o->client_shot_seq = _e; }
  { auto _e = weapon_id(); if (_e) _o->weapon_id = _e->str(); }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = origin_x(); _o->origin_x = _e; }
  { auto _e = origin_y(); _o->origin_y = _e; }
  { auto _e = origin_z(); _o->origin_z = _e; }
  { auto _e = dir_x(); _o->dir_x = _e; }
  { auto _e = dir_y(); _o->dir_y = _e; }
  { auto _e = dir_z(); _o->dir_z = _e; }
}

inline ::flatbuffers::Offset<FireWeaponRequest> CreateFireWeaponRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FireWeaponRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return FireWeaponRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FireWeaponRequest> FireWeaponRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FireWeaponRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FireWeaponRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_shot_seq = _o->client_shot_seq;
  auto _weapon_id = _o->weapon_id.empty() ? 0 : _fbb.CreateString(_o->weapon_id);
  auto _weapon_slot = _o->weapon_slot;
  auto _origin_x = _o->origin_x;
  auto _origin_y = _o->origin_y;
  auto _origin_z = _o->origin_z;
  auto _dir_x = _o->dir_x;
  auto _dir_y = _o->dir_y;
  auto _dir_z = _o->dir_z;
  return afps::protocol::CreateFireWeaponRequest(
      _fbb,
      _client_shot_seq,
      _weapon_id,
      _weapon_slot,
      _origin_x,
      _origin_y,
      _origin_z,
      _dir_x,
      _dir_y,
      _dir_z);
}

inline SetLoadoutRequestT *SetLoadoutRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetLoadoutRequestT>(new SetLoadoutRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetLoadoutRequest::UnPackTo(SetLoadoutRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = loadout_bits(); _o->loadout_bits = _e; }
}

inline ::flatbuffers::Offset<SetLoadoutRequest> CreateSetLoadoutRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SetLoadoutRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return SetLoadoutRequest::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetLoadoutRequest> SetLoadoutRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetLoadoutRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetLoadoutRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _loadout_bits = _o->loadout_bits;
  return afps::protocol::CreateSetLoadoutRequest(
      _fbb,
      _loadout_bits);
}

inline StateSnapshotT *StateSnapshot::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StateSnapshotT>(new StateSnapshotT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StateSnapshot::UnPackTo(StateSnapshotT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = server_tick(); _o->server_tick = _e; }
  { auto _e = last_processed_input_seq(); _o->last_processed_input_seq = _e; }
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = pos_x(); _o->pos_x = _e; }
  { auto _e = pos_y(); _o->pos_y = _e; }
  { auto _e = pos_z(); _o->pos_z = _e; }
  { auto _e = vel_x(); _o->vel_x = _e; }
  { auto _e = vel_y(); _o->vel_y = _e; }
  { auto _e = vel_z(); _o->vel_z = _e; }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = ammo_in_mag(); _o->ammo_in_mag = _e; }
  { auto _e = dash_cooldown(); _o->dash_cooldown = _e; }
  { auto _e = health(); _o->health = _e; }
  { auto _e = kills(); _o->kills = _e; }
  { auto _e = deaths(); _o->deaths = _e; }
  { auto _e = view_yaw_q(); _o->view_yaw_q = _e; }
  { auto _e = view_pitch_q(); _o->view_pitch_q = _e; }
  { auto _e = player_flags(); _o->player_flags = _e; }
  { auto _e = weapon_heat_q(); _o->weapon_heat_q = _e; }
  { auto _e = loadout_bits(); _o->loadout_bits = _e; }
}

inline ::flatbuffers::Offset<StateSnapshot> CreateStateSnapshot(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return StateSnapshot::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StateSnapshot> StateSnapshot::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StateSnapshotT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _server_tick = _o->server_tick;
  auto _last_processed_input_seq = _o->last_processed_input_seq;
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _pos_x = _o->pos_x;
  auto _pos_y = _o->pos_y;
  auto _pos_z = _o->pos_z;
  auto _vel_x = _o->vel_x;
  auto _vel_y = _o->vel_y;
  auto _vel_z = _o->vel_z;
  auto _weapon_slot = _o->weapon_slot;
  auto _ammo_in_mag = _o->ammo_in_mag;
  auto _dash_cooldown = _o->dash_cooldown;
  auto _health = _o->health;
  auto _kills = _o->kills;
  auto _deaths = _o->deaths;
  auto _view_yaw_q = _o->view_yaw_q;
  auto _view_pitch_q = _o->view_pitch_q;
  auto _player_flags = _o->player_flags;
  auto _weapon_heat_q = _o->weapon_heat_q;
  auto _loadout_bits = _o->loadout_bits;
  return afps::protocol::CreateStateSnapshot(
      _fbb,
      _server_tick,
      _last_processed_input_seq,
      _client_id,
      _pos_x,
      _pos_y,
      _pos_z,
      _vel_x,
      _vel_y,
      _vel_z,
      _weapon_slot,
      _ammo_in_mag,
      _dash_cooldown,
      _health,
      _kills,
      _deaths,
      _view_yaw_q,
      _view_pitch_q,
      _player_flags,
      _weapon_heat_q,
      _loadout_bits);
}

inline StateSnapshotDeltaT *StateSnapshotDelta::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StateSnapshotDeltaT>(new StateSnapshotDeltaT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StateSnapshotDelta::UnPackTo(StateSnapshotDeltaT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = server_tick(); _o->server_tick = _e; }
  { auto _e = base_tick(); _o->base_tick = _e; }
  { auto _e = last_processed_input_seq(); _o->last_processed_input_seq = _e; }
  { auto _e = mask(); _o->mask = _e; }
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = pos_x(); _o->pos_x = _e; }
  { auto _e = pos_y(); _o->pos_y = _e; }
  { auto _e = pos_z(); _o->pos_z = _e; }
  { auto _e = vel_x(); _o->vel_x = _e; }
  { auto _e = vel_y(); _o->vel_y = _e; }
  { auto _e = vel_z(); _o->vel_z = _e; }
  { auto _e = weapon_slot(); _o->weapon_slot = _e; }
  { auto _e = ammo_in_mag(); _o->ammo_in_mag = _e; }
  { auto _e = dash_cooldown(); _o->dash_cooldown = _e; }
  { auto _e = health(); _o->health = _e; }
  { auto _e = kills(); _o->kills = _e; }
  { auto _e = deaths(); _o->deaths = _e; }
  { auto _e = view_yaw_q(); _o->view_yaw_q = _e; }
  { auto _e = view_pitch_q(); _o->view_pitch_q = _e; }
  { auto _e = player_flags(); _o->player_flags = _e; }
  { auto _e = weapon_heat_q(); _o->weapon_heat_q = _e; }
  { auto _e = loadout_bits(); _o->loadout_bits = _e; }
}

inline ::flatbuffers::Offset<StateSnapshotDelta> CreateStateSnapshotDelta(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotDeltaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return StateSnapshotDelta::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StateSnapshotDelta> StateSnapshotDelta::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateSnapshotDeltaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StateSnapshotDeltaT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _server_tick = _o->server_tick;
  auto _base_tick = _o->base_tick;
  auto _last_processed_input_seq = _o->last_processed_input_seq;
  auto _mask = _o->mask;
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _pos_x = _o->pos_x;
  auto _pos_y = _o->pos_y;
  auto _pos_z = _o->pos_z;
  auto _vel_x = _o->vel_x;
  auto _vel_y = _o->vel_y;
  auto _vel_z = _o->vel_z;
  auto _weapon_slot = _o->weapon_slot;
  auto _ammo_in_mag = _o->ammo_in_mag;
  auto _dash_cooldown = _o->dash_cooldown;
  auto _health = _o->health;
  auto _kills = _o->kills;
  auto _deaths = _o->deaths;
  auto _view_yaw_q = _o->view_yaw_q;
  auto _view_pitch_q = _o->view_pitch_q;
  auto _player_flags = _o->player_flags;
  auto _weapon_heat_q = _o->weapon_heat_q;
  auto _loadout_bits = _o->loadout_bits;
  return afps::protocol::CreateStateSnapshotDelta(
      _fbb,
      _server_tick,
      _base_tick,
      _last_processed_input_seq,
      _mask,
      _client_id,
      _pos_x,
      _pos_y,
      _pos_z,
      _vel_x,
      _vel_y,
      _vel_z,
      _weapon_slot,
      _ammo_in_mag,
      _dash_cooldown,
      _health,
      _kills,
      _deaths,
      _view_yaw_q,
      _view_pitch_q,
      _player_flags,
      _weapon_heat_q,
      _loadout_bits);
}

inline PlayerProfileT *PlayerProfile::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlayerProfileT>(new PlayerProfileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerProfile::UnPackTo(PlayerProfileT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
  { auto _e = character_id(); if (_e) _o->character_id = _e->str(); }
}

inline ::flatbuffers::Offset<PlayerProfile> CreatePlayerProfile(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerProfileT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return PlayerProfile::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlayerProfile> PlayerProfile::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerProfileT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlayerProfileT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_id = _o->client_id.empty() ? 0 : _fbb.CreateString(_o->client_id);
  auto _nickname = _o->nickname.empty() ? 0 : _fbb.CreateString(_o->nickname);
  auto _character_id = _o->character_id.empty() ? 0 : _fbb.CreateString(_o->character_id);
  return afps::protocol::CreatePlayerProfile(
      _fbb,
      _client_id,
      _nickname,
      _character_id);
}

inline GameEventT *GameEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GameEventT>(new GameEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GameEvent::UnPackTo(GameEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = server_tick(); _o->server_tick = _e; }
  { auto _e = events_type(); if (_e) { _o->events.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->events[_i].type = static_cast<afps::protocol::FxEvent>(_e->Get(_i)); } } else { _o->events.resize(0); } }
  { auto _e = events(); if (_e) { _o->events.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->events[_i].value = afps::protocol::FxEventUnion::UnPack(_e->Get(_i), events_type()->GetEnum<FxEvent>(_i), _resolver); } } else { _o->events.resize(0); } }
}

inline ::flatbuffers::Offset<GameEvent> CreateGameEvent(::flatbuffers::FlatBufferBuilder &_fbb, const GameEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return GameEvent::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GameEvent> GameEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GameEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GameEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _server_tick = _o->server_tick;
  auto _events_type = _o->events.size() ? _fbb.CreateVector<FxEvent>(_o->events.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->events[i].type; }, &_va) : 0;
  auto _events = _o->events.size() ? _fbb.CreateVector<::flatbuffers::Offset<void>>(_o->events.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->events[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  return afps::protocol::CreateGameEvent(
      _fbb,
      _server_tick,
      _events_type,
      _events);
}

inline PingT *Ping::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PingT>(new PingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Ping::UnPackTo(PingT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_time_ms(); _o->client_time_ms = _e; }
}

inline ::flatbuffers::Offset<Ping> CreatePing(::flatbuffers::FlatBufferBuilder &_fbb, const PingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Ping::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Ping> Ping::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PingT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_time_ms = _o->client_time_ms;
  return afps::protocol::CreatePing(
      _fbb,
      _client_time_ms);
}

inline PongT *Pong::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PongT>(new PongT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pong::UnPackTo(PongT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_time_ms(); _o->client_time_ms = _e; }
}

inline ::flatbuffers::Offset<Pong> CreatePong(::flatbuffers::FlatBufferBuilder &_fbb, const PongT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Pong::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pong> Pong::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PongT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PongT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _client_time_ms = _o->client_time_ms;
  return afps::protocol::CreatePong(
      _fbb,
      _client_time_ms);
}

inline ErrorT *Error::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ErrorT>(new ErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Error::UnPackTo(ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<Error> CreateError(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Error::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Error> Error::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return afps::protocol::CreateError(
      _fbb,
      _code,
      _message);
}

inline DisconnectT *Disconnect::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DisconnectT>(new DisconnectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Disconnect::UnPackTo(DisconnectT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<Disconnect> CreateDisconnect(::flatbuffers::FlatBufferBuilder &_fbb, const DisconnectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Disconnect::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Disconnect> Disconnect::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DisconnectT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DisconnectT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return afps::protocol::CreateDisconnect(
      _fbb,
      _code,
      _message);
}

template <bool B>
inline bool VerifyFxEvent(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, FxEvent type) {
  switch (type) {
    case FxEvent::NONE: {
      return true;
    }
    case FxEvent::ShotFiredFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ShotFiredFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::ShotTraceFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ShotTraceFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::ReloadFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ReloadFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::NearMissFx: {
      auto ptr = reinterpret_cast<const afps::protocol::NearMissFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::OverheatFx: {
      auto ptr = reinterpret_cast<const afps::protocol::OverheatFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::VentFx: {
      auto ptr = reinterpret_cast<const afps::protocol::VentFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::HitConfirmedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::HitConfirmedFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::KillFeedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::KillFeedFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::ProjectileSpawnFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileSpawnFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::ProjectileImpactFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileImpactFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::ProjectileRemoveFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileRemoveFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::PickupSpawnedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::PickupSpawnedFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FxEvent::PickupTakenFx: {
      auto ptr = reinterpret_cast<const afps::protocol::PickupTakenFx *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

template <bool B>
inline bool VerifyFxEventVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<FxEvent> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFxEvent(
        verifier,  values->Get(i), types->GetEnum<FxEvent>(i))) {
      return false;
    }
  }
  return true;
}

inline void *FxEventUnion::UnPack(const void *obj, FxEvent type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case FxEvent::ShotFiredFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ShotFiredFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::ShotTraceFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ShotTraceFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::ReloadFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ReloadFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::NearMissFx: {
      auto ptr = reinterpret_cast<const afps::protocol::NearMissFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::OverheatFx: {
      auto ptr = reinterpret_cast<const afps::protocol::OverheatFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::VentFx: {
      auto ptr = reinterpret_cast<const afps::protocol::VentFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::HitConfirmedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::HitConfirmedFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::KillFeedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::KillFeedFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::ProjectileSpawnFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileSpawnFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::ProjectileImpactFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileImpactFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::ProjectileRemoveFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileRemoveFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::PickupSpawnedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::PickupSpawnedFx *>(obj);
      return ptr->UnPack(resolver);
    }
    case FxEvent::PickupTakenFx: {
      auto ptr = reinterpret_cast<const afps::protocol::PickupTakenFx *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> FxEventUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case FxEvent::ShotFiredFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ShotFiredFxT *>(value);
      return CreateShotFiredFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::ShotTraceFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ShotTraceFxT *>(value);
      return CreateShotTraceFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::ReloadFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ReloadFxT *>(value);
      return CreateReloadFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::NearMissFx: {
      auto ptr = reinterpret_cast<const afps::protocol::NearMissFxT *>(value);
      return CreateNearMissFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::OverheatFx: {
      auto ptr = reinterpret_cast<const afps::protocol::OverheatFxT *>(value);
      return CreateOverheatFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::VentFx: {
      auto ptr = reinterpret_cast<const afps::protocol::VentFxT *>(value);
      return CreateVentFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::HitConfirmedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::HitConfirmedFxT *>(value);
      return CreateHitConfirmedFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::KillFeedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::KillFeedFxT *>(value);
      return CreateKillFeedFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::ProjectileSpawnFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileSpawnFxT *>(value);
      return CreateProjectileSpawnFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::ProjectileImpactFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileImpactFxT *>(value);
      return CreateProjectileImpactFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::ProjectileRemoveFx: {
      auto ptr = reinterpret_cast<const afps::protocol::ProjectileRemoveFxT *>(value);
      return CreateProjectileRemoveFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::PickupSpawnedFx: {
      auto ptr = reinterpret_cast<const afps::protocol::PickupSpawnedFxT *>(value);
      return CreatePickupSpawnedFx(_fbb, ptr, _rehasher).Union();
    }
    case FxEvent::PickupTakenFx: {
      auto ptr = reinterpret_cast<const afps::protocol::PickupTakenFxT *>(value);
      return CreatePickupTakenFx(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline FxEventUnion::FxEventUnion(const FxEventUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case FxEvent::ShotFiredFx: {
      value = new afps::protocol::ShotFiredFxT(*reinterpret_cast<afps::protocol::ShotFiredFxT *>(u.value));
      break;
    }
    case FxEvent::ShotTraceFx: {
      value = new afps::protocol::ShotTraceFxT(*reinterpret_cast<afps::protocol::ShotTraceFxT *>(u.value));
      break;
    }
    case FxEvent::ReloadFx: {
      value = new afps::protocol::ReloadFxT(*reinterpret_cast<afps::protocol::ReloadFxT *>(u.value));
      break;
    }
    case FxEvent::NearMissFx: {
      value = new afps::protocol::NearMissFxT(*reinterpret_cast<afps::protocol::NearMissFxT *>(u.value));
      break;
    }
    case FxEvent::OverheatFx: {
      value = new afps::protocol::OverheatFxT(*reinterpret_cast<afps::protocol::OverheatFxT *>(u.value));
      break;
    }
    case FxEvent::VentFx: {
      value = new afps::protocol::VentFxT(*reinterpret_cast<afps::protocol::VentFxT *>(u.value));
      break;
    }
    case FxEvent::HitConfirmedFx: {
      value = new afps::protocol::HitConfirmedFxT(*reinterpret_cast<afps::protocol::HitConfirmedFxT *>(u.value));
      break;
    }
    case FxEvent::KillFeedFx: {
      value = new afps::protocol::KillFeedFxT(*reinterpret_cast<afps::protocol::KillFeedFxT *>(u.value));
      break;
    }
    case FxEvent::ProjectileSpawnFx: {
      value = new afps::protocol::ProjectileSpawnFxT(*reinterpret_cast<afps::protocol::ProjectileSpawnFxT *>(u.value));
      break;
    }
    case FxEvent::ProjectileImpactFx: {
      value = new afps::protocol::ProjectileImpactFxT(*reinterpret_cast<afps::protocol::ProjectileImpactFxT *>(u.value));
      break;
    }
    case FxEvent::ProjectileRemoveFx: {
      value = new afps::protocol::ProjectileRemoveFxT(*reinterpret_cast<afps::protocol::ProjectileRemoveFxT *>(u.value));
      break;
    }
    case FxEvent::PickupSpawnedFx: {
      value = new afps::protocol::PickupSpawnedFxT(*reinterpret_cast<afps::protocol::PickupSpawnedFxT *>(u.value));
      break;
    }
    case FxEvent::PickupTakenFx: {
      value = new afps::protocol::PickupTakenFxT(*reinterpret_cast<afps::protocol::PickupTakenFxT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void FxEventUnion::Reset() {
  switch (type) {
    case FxEvent::ShotFiredFx: {
      auto ptr = reinterpret_cast<afps::protocol::ShotFiredFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::ShotTraceFx: {
      auto ptr = reinterpret_cast<afps::protocol::ShotTraceFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::ReloadFx: {
      auto ptr = reinterpret_cast<afps::protocol::ReloadFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::NearMissFx: {
      auto ptr = reinterpret_cast<afps::protocol::NearMissFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::OverheatFx: {
      auto ptr = reinterpret_cast<afps::protocol::OverheatFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::VentFx: {
      auto ptr = reinterpret_cast<afps::protocol::VentFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::HitConfirmedFx: {
      auto ptr = reinterpret_cast<afps::protocol::HitConfirmedFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::KillFeedFx: {
      auto ptr = reinterpret_cast<afps::protocol::KillFeedFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::ProjectileSpawnFx: {
      auto ptr = reinterpret_cast<afps::protocol::ProjectileSpawnFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::ProjectileImpactFx: {
      auto ptr = reinterpret_cast<afps::protocol::ProjectileImpactFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::ProjectileRemoveFx: {
      auto ptr = reinterpret_cast<afps::protocol::ProjectileRemoveFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::PickupSpawnedFx: {
      auto ptr = reinterpret_cast<afps::protocol::PickupSpawnedFxT *>(value);
      delete ptr;
      break;
    }
    case FxEvent::PickupTakenFx: {
      auto ptr = reinterpret_cast<afps::protocol::PickupTakenFxT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = FxEvent::NONE;
}

}  // namespace protocol
}  // namespace afps

#endif  // FLATBUFFERS_GENERATED_AFPSPROTOCOL_AFPS_PROTOCOL_H_
